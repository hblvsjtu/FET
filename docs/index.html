<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>FET</title>
        <style>
</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="fet">FET</h1>
<h2 id="作者冰红茶">作者：冰红茶</h2>
<hr>
<p>平常在生活中或者工作中不断的学习前端知识，记录和分享吾之所见吾之所悟^_ ^</p>
<ul>
<li><a href="#fet">FET</a>
<ul>
<li><a href="#%E4%BD%9C%E8%80%85%E5%86%B0%E7%BA%A2%E8%8C%B6">作者：冰红茶</a></li>
<li><a href="#%E3%80%87%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87">〇、基础知识篇</a>
<ul>
<li><a href="#01-this%E4%B8%8E%E9%97%AD%E5%8C%85">0.1 this与闭包</a>
<ul>
<li><a href="#1-this%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7">1) this的优先级</a></li>
<li><a href="#2-%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B009">2) 按顺序打印0～9</a></li>
<li><a href="#3-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8C%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA">3) 变量提升和暂时性死区</a></li>
<li><a href="#4-%E9%97%AD%E5%8C%85">4) 闭包</a></li>
<li><a href="#5-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5">5) 内存泄漏的几种情况</a></li>
</ul>
</li>
<li><a href="#02-%E5%BC%82%E6%AD%A5">0.2 异步</a>
<ul>
<li><a href="#1-3%E7%A7%92%E5%90%8E%E4%BA%AE%E7%BA%A2%E7%81%AF1%E7%A7%92%E5%90%8E%E4%BA%AE%E7%BB%BF%E7%81%AF2%E7%A7%92%E5%90%8E%E4%BA%AE%E9%BB%84%E7%81%AF%E5%86%8D%E5%91%A8%E8%80%8C%E5%A4%8D%E5%A7%8B">1) 3秒后亮红灯，1秒后亮绿灯，2秒后亮黄灯，再周而复始</a></li>
<li><a href="#2-%E5%90%8C%E6%97%B6%E6%9C%80%E5%A4%9An%E4%B8%AA%E5%B9%B6%E5%8F%91">2) 同时最多N个并发</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%80%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E7%AF%87">一、类型判断篇</a>
<ul>
<li><a href="#11-%E5%9F%BA%E6%9C%AC%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B">1.1 基本数字类型</a>
<ul>
<li><a href="#1-null">1) null</a></li>
<li><a href="#2-nan">2) NaN</a></li>
<li><a href="#3-undefined">3) undefined</a></li>
<li><a href="#4-number">4) number</a></li>
<li><a href="#5-boolean">5) boolean</a></li>
</ul>
</li>
<li><a href="#12-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F">1.2 对象类型系统</a>
<ul>
<li><a href="#1-object">1) object</a></li>
<li><a href="#2-%E5%87%BD%E6%95%B0">2) 函数</a></li>
<li><a href="#3-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">3) 正则表达式</a></li>
<li><a href="#4-%E6%97%A5%E6%9C%9F">4) 日期</a></li>
<li><a href="#5-%E6%95%B0%E7%BB%84">5) 数组</a></li>
<li><a href="#6-%E5%85%A8%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD">6) 全类型判断</a></li>
</ul>
</li>
<li><a href="#13-%E5%B9%B3%E5%8F%B0">1.3 平台</a>
<ul>
<li><a href="#1-window">1) window</a></li>
<li><a href="#2%E6%B5%8F%E8%A7%88%E5%99%A8">2）浏览器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E7%AF%87">二、常用方法篇</a>
<ul>
<li><a href="#21-%E6%8B%B7%E8%B4%9D">2.1 拷贝</a>
<ul>
<li><a href="#1-%E6%95%B0%E7%BB%84%E6%B5%85%E6%8B%B7%E8%B4%9D">1) 数组浅拷贝</a></li>
<li><a href="#2-%E6%95%B0%E7%BB%84%E6%B7%B1%E6%8B%B7%E8%B4%9D">2) 数组深拷贝</a></li>
</ul>
</li>
<li><a href="#22-%E7%B1%BB%E6%95%B0%E7%BB%84%E5%88%A4%E6%96%AD%E4%B8%8E%E8%BD%AC%E5%8C%96">2.2 类数组判断与转化</a>
<ul>
<li><a href="#1-%E5%88%A4%E6%96%AD">1) 判断</a></li>
<li><a href="#2-slice%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0">2) slice的内部实现</a></li>
<li><a href="#3-%E8%BD%AC%E5%8C%96">3) 转化</a></li>
</ul>
</li>
<li><a href="#24-%E6%95%B0%E7%BB%84%E4%B9%B1%E5%BA%8F">2.4 数组乱序</a></li>
<li><a href="#28-ajax%E5%B0%81%E8%A3%85">2.8 ajax封装</a>
<ul>
<li><a href="#1-%E5%8A%9F%E8%83%BD">1) 功能</a></li>
</ul>
</li>
<li><a href="#29-stringformat">2.9 String.format</a>
<ul>
<li><a href="#1-%E5%8A%9F%E8%83%BD-1">1) 功能</a></li>
<li><a href="#2-%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%8A%A0%E7%AE%80%E4%BB%8B%E7%9A%84%E5%8A%9E%E6%B3%95%E5%88%A9%E7%94%A8replace">2) 一个更加简介的办法：利用replace()</a></li>
</ul>
</li>
<li><a href="#210-stringthousandsplit">2.10 String.thousandSplit</a>
<ul>
<li><a href="#1-%E5%8A%9F%E8%83%BD-2">1) 功能</a></li>
<li><a href="#2-%E5%AE%9E%E7%8E%B0">2) 实现</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%89%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%E7%AF%87">三、原理实现篇</a>
<ul>
<li><a href="#31-callapplybind">3.1 call/apply/bind</a>
<ul>
<li><a href="#1-call">1) call</a></li>
<li><a href="#2-apply">2) apply</a></li>
<li><a href="#3-bind">3) bind</a></li>
</ul>
</li>
<li><a href="#32-deferred%E5%92%8Cpromise">3.2 Deferred和Promise</a>
<ul>
<li><a href="#1-promisea%E8%A7%84%E8%8C%83">1) promise/A规范</a></li>
<li><a href="#2-deferredpromise">2) Deferred/promise</a></li>
<li><a href="#2-promise%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84">2) Promise(第一次自己写的)</a></li>
<li><a href="#3-promise%E7%9C%8B%E4%BA%86%E5%88%AB%E4%BA%BA%E4%BB%A3%E7%A0%81%E5%90%8E%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84">3) Promise(看了别人代码后自己写的)</a></li>
</ul>
</li>
<li><a href="#34-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F">3.4 观察者模式</a>
<ul>
<li><a href="#1-%E8%A6%81%E7%82%B9">1) 要点</a></li>
<li><a href="#2-%E4%BB%A3%E7%A0%81">2) 代码</a></li>
</ul>
</li>
<li><a href="#35-%E9%98%B2%E6%8A%96%E5%8A%A8%E5%92%8C%E6%88%AA%E6%B5%81">3.5 防抖动和截流</a>
<ul>
<li><a href="#1-%E7%9B%B8%E5%90%8C%E7%82%B9">1) 相同点</a></li>
<li><a href="#2-%E4%B8%8D%E5%90%8C%E7%82%B9">2) 不同点</a></li>
<li><a href="#3-%E9%98%B2%E6%8A%96%E5%8A%A8">3) 防抖动</a></li>
<li><a href="#4-%E6%88%AA%E6%B5%81%E9%A2%91%E7%8E%87%E6%8E%A7%E5%88%B6">4) 截流/频率控制</a></li>
<li><a href="#5-%E9%98%B2%E6%8A%96%E5%8A%A8%E5%92%8C%E6%88%AA%E6%B5%81%E5%90%88%E5%B9%B6">5) 防抖动和截流合并</a></li>
</ul>
</li>
<li><a href="#36-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF">3.6 类的继承</a>
<ul>
<li><a href="#1-%E5%B1%9E%E6%80%A7%E6%8B%B7%E8%B4%9D">1) 属性拷贝</a></li>
<li><a href="#2-%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF">2) 原型式继承</a></li>
<li><a href="#3-%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF">3) 原型链继承</a></li>
<li><a href="#4-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF">4) 构造函数继承</a></li>
<li><a href="#5-%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF">5) 组合继承</a></li>
<li><a href="#6-%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%E4%BC%98%E5%8C%961">6) 组合继承优化1</a></li>
<li><a href="#7-%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%E4%BC%98%E5%8C%962">7) 组合继承优化2</a></li>
</ul>
</li>
<li><a href="#37-new">3.7 new</a>
<ul>
<li><a href="#1-%E8%A6%81%E7%82%B9-1">1) 要点</a></li>
</ul>
</li>
<li><a href="#38-objectcreate">3.8 Object.create()</a>
<ul>
<li><a href="#1-%E5%8F%82%E6%95%B0">1) 参数</a></li>
</ul>
</li>
<li><a href="#39-objectkeysobjectvaluesobjectentries">3.9 Object.keys/Object.values/Object.entries</a>
<ul>
<li><a href="#1-objectkeys">1) Object.keys</a></li>
<li><a href="#2-objectvalues">2) Object.values</a></li>
<li><a href="#2-objectentrie">2) Object.entrie</a></li>
</ul>
</li>
<li><a href="#310-settimeout-%E4%B8%8E-setinterval">3.10 setTimeout 与 setInterval</a>
<ul>
<li><a href="#1-%E6%9C%80%E7%9F%AD%E9%97%B4%E9%9A%94%E6%97%B6%E9%97%B4">1) 最短间隔时间</a></li>
</ul>
</li>
<li><a href="#311-%E8%B7%A8%E5%9F%9F">3.11 跨域</a>
<ul>
<li><a href="#1-%E9%80%9A%E8%BF%87documentdomain%E8%B7%A8%E5%9F%9F">1) 通过document.domain跨域</a></li>
<li><a href="#2-%E9%80%9A%E8%BF%87locationhash%E8%B7%A8%E5%9F%9F">2) 通过location.hash跨域</a></li>
<li><a href="#3-%E9%80%9A%E8%BF%87postmessage">3) 通过postMessage</a></li>
<li><a href="#4-jsonp">4) Jsonp</a></li>
<li><a href="#5-access-control-allow-origin">5) Access-Control-Allow-Origin</a></li>
</ul>
</li>
<li><a href="#312-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96">3.12 函数柯里化</a>
<ul>
<li><a href="#1-%E5%AE%9A%E4%B9%89">1) 定义</a></li>
<li><a href="#2-%E4%B8%A4%E6%AE%B5%E4%B8%8D%E5%AE%9A%E5%8F%82%E6%95%B0%E7%89%88%E6%9C%AC">2) 两段不定参数版本</a></li>
<li><a href="#3-%E4%B8%8D%E5%AE%9A%E6%AE%B5%E4%B8%8D%E5%AE%9A%E5%8F%82%E6%95%B0%E7%89%88%E6%9C%AC">3) 不定段不定参数版本</a></li>
</ul>
</li>
<li><a href="#313-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0">3.13 高阶函数</a>
<ul>
<li><a href="#1-%E5%AE%9A%E4%B9%89-1">1) 定义</a></li>
<li><a href="#2-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAmap%E5%87%BD%E6%95%B0">2) 实现一个map函数</a></li>
<li><a href="#3-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAforeach%E5%87%BD%E6%95%B0">3) 实现一个forEach函数</a></li>
<li><a href="#4-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAreduce%E5%87%BD%E6%95%B0">4) 实现一个reduce函数</a></li>
<li><a href="#5-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAfilter%E5%87%BD%E6%95%B0">5) 实现一个filter函数</a></li>
</ul>
</li>
<li><a href="#314-%E8%BF%AD%E4%BB%A3%E5%99%A8">3.14 迭代器</a>
<ul>
<li><a href="#1-%E5%AE%9A%E4%B9%89-2">1) 定义</a></li>
</ul>
</li>
<li><a href="#315-instanceof">3.15 instanceof</a>
<ul>
<li><a href="#1-%E5%AE%9A%E4%B9%89-3">1) 定义</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%9B%9B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">四、正则表达式</a>
<ul>
<li><a href="#41-%E6%96%AD%E8%A8%80">4.1 断言</a>
<ul>
<li><a href="#1-%E5%AE%9A%E4%B9%89-4">1) 定义</a></li>
<li><a href="#2-%E7%B1%BB%E5%9E%8B">2) 类型</a></li>
</ul>
</li>
<li><a href="#42-%E5%8F%8D%E5%90%91%E5%BC%95%E7%94%A8">4.2 反向引用</a>
<ul>
<li><a href="#1-%E5%AE%9A%E4%B9%89-5">1) 定义</a></li>
<li><a href="#2-%E8%A6%81%E7%82%B9">2) 要点</a></li>
</ul>
</li>
<li><a href="#43-%E9%9D%9E%E8%B4%AA%E5%A9%AA">4.3 非贪婪</a>
<ul>
<li><a href="#1-%E5%AE%9A%E4%B9%89-6">1) 定义</a></li>
</ul>
</li>
<li><a href="#44-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E8%BA%AB%E4%BB%BD%E8%AF%81%E7%BD%91%E5%9D%80%E9%82%AE%E7%AE%B1">4.4 电话号码/身份证/网址/邮箱</a>
<ul>
<li><a href="#1-qq%E5%8F%B7%E7%A0%81">1) QQ号码</a></li>
<li><a href="#2-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81">2) 电话号码</a></li>
<li><a href="#3-%E8%BA%AB%E4%BB%BD%E8%AF%81">3) 身份证</a></li>
<li><a href="#3-%E7%BD%91%E5%9D%80">3) 网址</a></li>
<li><a href="#4-%E9%82%AE%E7%AE%B1">4) 邮箱</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BA%94js%E5%92%8Chtml%E6%95%88%E6%9E%9C%E7%AF%87">五、js和html效果篇</a>
<ul>
<li><a href="#51-%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E6%A0%B7%E5%BC%8F%E4%BD%8D%E7%BD%AE%E5%B0%BA%E5%AF%B8">5.1 获取元素样式/位置/尺寸</a>
<ul>
<li><a href="#1-%E6%A0%B7%E5%BC%8F">1) 样式</a></li>
<li><a href="#2-%E4%BD%8D%E7%BD%AE">2) 位置</a></li>
</ul>
</li>
<li><a href="#52-%E6%8B%96%E6%8B%BD">5.2 拖拽</a>
<ul>
<li><a href="#1-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0">1) 行内元素</a></li>
</ul>
</li>
<li><a href="#53-%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD">5.3 图片懒加载</a>
<ul>
<li><a href="#1-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0-1">1) 行内元素</a></li>
</ul>
</li>
<li><a href="#54-%E8%BD%AE%E6%92%AD">5.4 轮播</a>
<ul>
<li><a href="#1-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0-2">1) 行内元素</a></li>
</ul>
</li>
<li><a href="#55-%E6%BB%91%E5%8A%A8">5.5 滑动</a>
<ul>
<li><a href="#1-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0-3">1) 行内元素</a></li>
</ul>
</li>
<li><a href="#56-%E7%BA%A7%E8%81%94">5.6 级联</a>
<ul>
<li><a href="#1-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0-4">1) 行内元素</a></li>
</ul>
</li>
<li><a href="#57-%E5%9B%BE%E7%89%87%E5%89%AA%E8%A3%81">5.7 图片剪裁</a>
<ul>
<li><a href="#1-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0-5">1) 行内元素</a></li>
</ul>
</li>
<li><a href="#58-%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9">5.8 图片压缩</a>
<ul>
<li><a href="#1-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0-6">1) 行内元素</a></li>
</ul>
</li>
<li><a href="#59-tab">5.9 Tab</a>
<ul>
<li><a href="#1-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0-7">1) 行内元素</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%85%ADcss%E6%95%88%E6%9E%9C%E7%AF%87">六、CSS效果篇</a>
<ul>
<li><a href="#61-%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD">6.1 水平居中</a>
<ul>
<li><a href="#1-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0-8">1) 行内元素</a></li>
<li><a href="#2-%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0">2) 块级元素</a></li>
</ul>
</li>
<li><a href="#62-%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD">6.2 垂直居中</a>
<ul>
<li><a href="#1-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0-9">1) 行内元素</a></li>
<li><a href="#2-%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0-1">2) 块级元素</a></li>
</ul>
</li>
<li><a href="#63-%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD">6.3 水平垂直居中</a>
<ul>
<li><a href="#1-%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8Dauto%E6%96%B9%E6%A1%88">1) 绝对定位auto方案</a></li>
<li><a href="#2-%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8Dtranslate%E6%96%B9%E6%A1%88">2) 绝对定位translate方案</a></li>
<li><a href="#3-inline-block%E6%96%B9%E6%A1%88">3) inline-block方案</a></li>
<li><a href="#4-table-cell%E6%96%B9%E6%A1%88">4) table-cell方案</a></li>
</ul>
</li>
<li><a href="#64-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8">6.4 清除浮动</a>
<ul>
<li><a href="#1-%E5%8E%9F%E5%9B%A0">1) 原因</a></li>
<li><a href="#2-%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">2) 解决办法</a></li>
</ul>
</li>
<li><a href="#65-%E5%B9%BD%E7%81%B5%E7%A9%BA%E7%99%BD%E8%8A%82%E7%82%B9">6.5 幽灵空白节点</a>
<ul>
<li><a href="#1-w3c%E8%A7%84%E8%8C%83">1) W3C规范</a></li>
<li><a href="#2-%E5%A6%82%E4%BD%95%E6%B6%88%E9%99%A4%E5%91%A2">2) 如何消除呢？</a></li>
</ul>
</li>
<li><a href="#66-%E4%B8%89%E5%88%97%E5%B8%83%E5%B1%80">6.6 三列布局</a>
<ul>
<li><a href="#1-%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80">1) 双飞翼布局</a></li>
<li><a href="#2-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80">2) 圣杯布局</a></li>
<li><a href="#3-%E7%AE%80%E5%8D%95float%E5%B8%83%E5%B1%80">3) 简单float布局</a></li>
<li><a href="#4-%E7%BB%9D%E5%AF%B9float%E5%B8%83%E5%B1%80">4) 绝对float布局</a></li>
<li><a href="#5-%E7%BB%9D%E5%AF%B9%E5%B8%83%E5%B1%80">5) 绝对布局</a></li>
</ul>
</li>
<li><a href="#67-%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80">6.7 弹性布局</a>
<ul>
<li><a href="#1-%E5%AE%B9%E5%99%A8">1) 容器</a></li>
<li><a href="#2-%E4%B8%BB%E8%BD%B4%E6%96%B9%E5%90%91flex-direction">2) 主轴方向：flex-direction:</a></li>
<li><a href="#3-%E6%8D%A2%E8%A1%8C%E6%98%BE%E7%A4%BAflex-wrap">3) 换行显示：flex-wrap</a></li>
<li><a href="#4-flex-flow">4) flex-flow</a></li>
<li><a href="#5-%E5%AE%9A%E4%B9%89%E9%A1%B9%E7%9B%AE%E5%9C%A8%E4%B8%BB%E8%BD%B4%E4%B8%8A%E7%9A%84%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8Fjustify-content">5) 定义项目在主轴上的对齐方式：justify-content</a></li>
<li><a href="#6-%E5%AE%9A%E4%B9%89%E9%A1%B9%E7%9B%AE%E5%9C%A8%E4%BA%A4%E5%8F%89%E8%BD%B4%E4%B8%8A%E7%9A%84%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8Falign-items">6) 定义项目在交叉轴上的对齐方式：align-items</a></li>
<li><a href="#7-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7">7) 项目中的属性</a></li>
<li><a href="#7-align-self">7) align-self</a></li>
<li><a href="#8-flex-grow%E5%92%8Cflex-shrink%E7%9B%B8%E5%85%B3%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F">8) flex-grow和flex-shrink相关计算公式</a></li>
<li><a href="#9-%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80">9) 手写一个圣杯布局</a></li>
</ul>
</li>
<li><a href="#68-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80">6.8 响应式布局</a>
<ul>
<li><a href="#1-null-1">1) null</a></li>
</ul>
</li>
<li><a href="#69-%E5%8F%98%E5%BD%A2%E5%8A%A8%E7%94%BB">6.9 变形动画</a>
<ul>
<li><a href="#1-%E4%BA%8C%E7%BB%B4%E5%8A%A8%E7%94%BB">1) 二维动画</a></li>
<li><a href="#2-%E4%B8%89%E7%BB%B4%E5%8A%A8%E7%94%BB">2) 三维动画</a></li>
</ul>
</li>
<li><a href="#610-%E8%A1%A5%E9%97%B4%E5%8A%A8%E7%94%BB">6.10 补间动画</a>
<ul>
<li><a href="#1-null-2">1) null</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B9%9D%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AF%87">九、浏览器篇</a>
<ul>
<li><a href="#93-defer%E5%92%8Casync%E7%9A%84%E5%8C%BA%E5%88%AB">9.3 defer和async的区别</a>
<ul>
<li><a href="#1-%E7%9B%B8%E5%90%8C%E7%82%B9-1">1) 相同点</a></li>
<li><a href="#2-%E4%B8%8D%E5%90%8C%E7%82%B9-1">2) 不同点</a></li>
</ul>
</li>
<li><a href="#95-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%A7%E8%83%BD%E5%92%8C%E8%AE%A1%E6%97%B6%E5%99%A8">9.5 浏览器性能和计时器</a>
<ul>
<li><a href="#1-%E9%AB%98%E6%B6%88%E8%80%97%E7%9A%84%E6%A0%B7%E5%BC%8F">1) 高消耗的样式</a></li>
<li><a href="#2-%E5%87%8F%E5%B0%91%E9%87%8D%E6%8E%92reflow%E7%9A%84%E7%BB%8F%E9%AA%8C">2) 减少重排Reflow的经验</a></li>
<li><a href="#3-%E4%BC%98%E5%8C%96%E5%8A%A8%E7%94%BB%E6%80%A7%E8%83%BD">3) 优化动画性能</a></li>
</ul>
</li>
<li><a href="#100-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF">10.0 事件循环</a>
<ul>
<li><a href="#1-%E4%B8%BB%E7%BA%BF%E7%A8%8B">1) 主线程</a></li>
<li><a href="#2-%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97macrotasks">2) 任务队列(Macrotasks)</a></li>
<li><a href="#3-%E5%BE%AE%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97microtasks">3) 微任务队列(Microtasks)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="〇基础知识篇">〇、基础知识篇</h2>
<h3 id="01-this与闭包">0.1 this与闭包</h3>
<h4 id="1-this的优先级">1) this的优先级</h4>
<blockquote>
<ul>
<li>箭头函数</li>
<li>new</li>
<li>call,apply,bind</li>
<li>对象的函数属性调用</li>
<li>全局window的函数属性调用</li>
</ul>
</blockquote>
<h4 id="2-按顺序打印09">2) 按顺序打印0～9</h4>
<blockquote>
<ul>
<li>1秒后同时打印0～9 关键点在于创造n个不同的独立作用域</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>    <span class="hljs-comment">// 闭包</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
        (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>) </span>{
            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-built_in">console</span>.log(j)}, <span class="hljs-number">1000</span>);
        })(i);
    }

    <span class="hljs-comment">// let</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-built_in">console</span>.log(a)}, <span class="hljs-number">1000</span>);
    }
</div></code></pre>
<blockquote>
<ul>
<li>每秒按顺序打印0～9</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">// setInterval法</span>
        i = <span class="hljs-number">0</span>;
        timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(i++);
            <span class="hljs-keyword">if</span>(i === <span class="hljs-number">10</span>) <span class="hljs-built_in">clearInterval</span>(timer);
        }, <span class="hljs-number">1000</span>);

        <span class="hljs-comment">// promise法</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDelayPromise</span>(<span class="hljs-params">i</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>)</span>{
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{resolve(i)}, <span class="hljs-number">1000</span>);
            })
        };
        <span class="hljs-keyword">var</span> delay = getDelayPromise(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
            delay = delay.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>{
        <span class="hljs-built_in">console</span>.log(res);
        <span class="hljs-keyword">return</span> getDelayPromise(res + <span class="hljs-number">1</span>);
            });
        };

        <span class="hljs-comment">// await法</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDelayPromise</span>(<span class="hljs-params">i</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>)</span>{
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{resolve(i)}, <span class="hljs-number">1000</span>);
            })
        };

        (<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> getDelayPromise(i));
            }
        })();
}
</div></code></pre>
<h4 id="3-变量提升和暂时性死区">3) 变量提升和暂时性死区</h4>
<blockquote>
<ul>
<li>这两个概念是相对而言的</li>
<li>js 是一种解释性的语言 分为<code>预编译阶段</code>和<code>执行阶段</code>，<code>执行阶段</code>中解释一行然后执行一行。在预编译过程为了提前预先配好内存，中会对函数中的var变量声明部分提前提升至函数的开始，并赋值为undefined，然后在执行过程中再重新赋值。这个过程成为<code>变量提升</code>。而<code>let</code>和<code>const</code>则不那么幸运，<code>预编译阶段</code>不会被【提升】，所以从函数开始到变量声明前被成为<code>暂时性死区</code>，访问的时候会报<code>referenceError</code>引用错误。</li>
<li>函数的变量在预编译阶段被创建，在执行阶段被激活，在函数执行完毕后的下一个垃圾回收GC节点被回收，其上下文也会被销毁</li>
</ul>
</blockquote>
<h4 id="4-闭包">4) 闭包</h4>
<blockquote>
<ul>
<li>函数嵌套时，内部函数可访问了外部函数的作用域变量，哪怕内部函数是在全局环境下被调用</li>
<li>一般来说是全局环境是不可访问函数内部的变量的，但是通过闭包，就可以实现对函数内部变量的访问，并且不会污染全局变量</li>
<li>有个坏处，容易造成内存泄露，不用的时候需要把内部函数的引用置为null</li>
<li>闭包只使用内部函数在第一次建立时候的作用域链</li>
</ul>
</blockquote>
<h4 id="5-内存泄漏的几种情况">5) 内存泄漏的几种情况</h4>
<blockquote>
<ul>
<li>闭包</li>
<li>删除节点</li>
<li>设置事件监听</li>
</ul>
</blockquote>
<h3 id="02-异步">0.2 异步</h3>
<h4 id="1-3秒后亮红灯1秒后亮绿灯2秒后亮黄灯再周而复始">1) 3秒后亮红灯，1秒后亮绿灯，2秒后亮黄灯，再周而复始</h4>
<pre><code class="language-js"><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDelayPromise</span>(<span class="hljs-params">delay</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span>
            <span class="hljs-built_in">setTimeout</span>(resolve, delay)
        )
    };
    [
        {<span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-attr">delay</span>: <span class="hljs-number">3000</span>},
        {<span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-attr">delay</span>: <span class="hljs-number">1000</span>},
        {<span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-attr">delay</span>: <span class="hljs-number">2000</span>},
    ].reduce(<span class="hljs-function">(<span class="hljs-params">promise, {color, delay}</span>) =&gt;</span>
        promise.then(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`亮起<span class="hljs-subst">${color}</span>灯；`</span>);
            <span class="hljs-keyword">return</span> getDelayPromise(delay);
        }),
        <span class="hljs-built_in">Promise</span>.resolve()
    );
</div></code></pre>
<h4 id="2-同时最多n个并发">2) 同时最多N个并发</h4>
<blockquote>
<ul>
<li>使用promise.race</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPromise</span>(<span class="hljs-params">item</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span>
            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(item), item * <span class="hljs-number">1000</span>)
        )
    };
    <span class="hljs-keyword">var</span> arr = <span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">Array</span>(<span class="hljs-number">10</span>), <span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> index);
    
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">concurrent</span>(<span class="hljs-params">targetArray, maxThreadNum, getPromise</span>) </span>{
        <span class="hljs-keyword">if</span> (targetArray.length &lt;= maxThreadNum) {
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(targetArray.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> getPromise(item)));
        }
        <span class="hljs-keyword">const</span> result = [];
        <span class="hljs-keyword">const</span> threads = targetArray.slice(<span class="hljs-number">0</span>, maxThreadNum);
        <span class="hljs-keyword">const</span> threadsPromiseList = threads.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> getPromise(item));
        <span class="hljs-keyword">return</span> targetArray.slice(maxThreadNum).reduce(
            <span class="hljs-function">(<span class="hljs-params">promise, item, index</span>) =&gt;</span>
        promise.then(
            <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
                result.push(res);
                <span class="hljs-keyword">const</span> positionIndex = threads.indexOf(res);
                threads.splice(positionIndex, <span class="hljs-number">1</span>, item);
                threadsPromiseList.splice(positionIndex, <span class="hljs-number">1</span>, getPromise(item));
                <span class="hljs-built_in">console</span>.log(res, positionIndex, threads, threadsPromiseList);
                <span class="hljs-keyword">if</span> (index === targetArray.length - maxThreadNum - <span class="hljs-number">1</span>) {
                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(threadsPromiseList)
                }
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.race(threadsPromiseList)
            }
        ),
            <span class="hljs-built_in">Promise</span>.race(threadsPromiseList)
        )
        .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(result.concat(res)))
        .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(err));
    }

    concurrent(arr, <span class="hljs-number">3</span>, getPromise);

</div></code></pre>
<h2 id="一类型判断篇">一、类型判断篇</h2>
<h3 id="11-基本数字类型">1.1 基本数字类型</h3>
<h4 id="1-null">1) null</h4>
<blockquote>
<ul>
<li>直接跟v他自己比较即可</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNull</span>(<span class="hljs-params">o</span>) </span>{
            <span class="hljs-keyword">return</span> o === <span class="hljs-literal">null</span>;
        }
</div></code></pre>
<h4 id="2-nan">2) NaN</h4>
<blockquote>
<ul>
<li>因为它连跟它自己比较都不相等，可以用此特性进行判断</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNaN</span>(<span class="hljs-params">o</span>) </span>{
            <span class="hljs-keyword">return</span> o !== o;
        }
</div></code></pre>
<h4 id="3-undefined">3) undefined</h4>
<blockquote>
<ul>
<li>undefined它并不是一个保留词，他是全局对象的一个属性，这说明什么呢？说明它有可能会被改写。到了ES5被改成只读了，但是在局部作用域中还是会被改写，虽然在最新的chrome 75.0.3770.142中我并没有发现改写-.-||</li>
<li>为什么是void 0? 因为根据MDN的解释：The void operator evaluates the given expression and then returns undefined. 无论你给他赋什么的值，都会返回undefined，而0应该是最简单的喽</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isUndefined</span>(<span class="hljs-params">o</span>) </span>{
            <span class="hljs-keyword">return</span> o === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
        }
</div></code></pre>
<h4 id="4-number">4) number</h4>
<blockquote>
<ul>
<li>采用鸭子辩型</li>
<li>因为如果纯粹使用typeof的话会把包装类也识别成对象；</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNumber</span>(<span class="hljs-params">o</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;[object Number]&#x27;</span> === {}.toString.call(o) &amp;&amp; <span class="hljs-built_in">isFinite</span>(o); 
        }
</div></code></pre>
<h4 id="5-boolean">5) boolean</h4>
<blockquote>
<ul>
<li>采用鸭子辩型</li>
<li>因为如果纯粹使用typeof的话会把包装类也识别成对象；</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isboolean</span>(<span class="hljs-params">o</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;[object Boolean]&#x27;</span> === {}.toString.call(o); 
        }
</div></code></pre>
<h3 id="12-对象类型系统">1.2 对象类型系统</h3>
<h4 id="1-object">1) object</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isObject</span>(<span class="hljs-params">o</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;[object Object]&#x27;</span> === {}.toString.call(o); 
        }
</div></code></pre>
<h4 id="2-函数">2) 函数</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFunction</span>(<span class="hljs-params">o</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;[object Function]&#x27;</span> === {}.toString.call(o); 
        }
</div></code></pre>
<h4 id="3-正则表达式">3) 正则表达式</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isRegExp</span>(<span class="hljs-params">o</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;[object RegExp]&#x27;</span> === {}.toString.call(o); 
        }
</div></code></pre>
<h4 id="4-日期">4) 日期</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isDate</span>(<span class="hljs-params">o</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;[object Date]&#x27;</span> === {}.toString.call(o); 
        }
</div></code></pre>
<h4 id="5-数组">5) 数组</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isArray</span>(<span class="hljs-params">o</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;[object Array]&#x27;</span> === {}.toString.call(o); 
        }
</div></code></pre>
<h4 id="6-全类型判断">6) 全类型判断</h4>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
         * 
         * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
         * <span class="hljs-doctag">@date    </span>2019-08-01
         * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
         */</span>

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">type</span>(<span class="hljs-params">o</span>) </span>{
            <span class="hljs-keyword">if</span>(o === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;null&quot;</span>;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(o !== o) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NaN&quot;</span>;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(o === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;undefined&quot;</span>;
            <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">let</span> type = {}.toString.call(o).slice(<span class="hljs-number">8</span>, <span class="hljs-number">-1</span>);
                <span class="hljs-keyword">return</span> type ? type : <span class="hljs-string">&#x27;它不是基本类型&#x27;</span>
            }
        }
</div></code></pre>
<h3 id="13-平台">1.3 平台</h3>
<h4 id="1-window">1) window</h4>
<blockquote>
<ul>
<li>需要区分不同的平台</li>
<li>IE6、7、8利用window == document为真 但是document == window为假的神奇特性</li>
<li>标准浏览器及IE9,IE10等使用鸭子辩型的方法</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
         * 
         * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
         * <span class="hljs-doctag">@date    </span>2019-08-01
         * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
         */</span>

        <span class="hljs-comment">// IE6、7、8</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isWindow</span>(<span class="hljs-params">obj</span>) </span>{
            <span class="hljs-keyword">return</span> obj == obj.document &amp;&amp; obj.document != obj;
        }
        <span class="hljs-comment">// 标准浏览器及IE9,IE10</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isWindow</span>(<span class="hljs-params">obj</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-regexp">/^\[object (Window|DOMWindow|global)/</span>.test({}.toString.call(obj));
        }
</div></code></pre>
<h4 id="2浏览器">2）浏览器</h4>
<blockquote>
<ul>
<li>判断浏览器类型</li>
<li>利用navigator.userAgent来判断</li>
<li>要把browsers数组里面的子项按照顺序来放，因为有时候userAgent里面会同时出现两种或以上的子项，当Safari出现的时候一般在userAgent的最后面，而&quot;Chrome&quot;次之，所以需要把他们放在前面先进行遍历</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
         * 
         * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
         * <span class="hljs-doctag">@date    </span>2019-08-01
         * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
         */</span>

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myBrowser</span>(<span class="hljs-params"></span>)</span>{
            <span class="hljs-keyword">var</span> userAgent = navigator.userAgent; <span class="hljs-comment">//取得浏览器的userAgent字符串</span>
            <span class="hljs-comment">// 此处要把</span>
            <span class="hljs-keyword">let</span> browsers = [<span class="hljs-string">&quot;Safari&quot;</span>, <span class="hljs-string">&quot;Opera&quot;</span>, <span class="hljs-string">&quot;Firefox&quot;</span>, <span class="hljs-string">&quot;Chrome&quot;</span>, <span class="hljs-string">&quot;Edge&quot;</span>, <span class="hljs-string">&quot;compatible&quot;</span>];
            <span class="hljs-keyword">let</span> browser = <span class="hljs-string">&#x27;&#x27;</span>;
            browsers.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
                <span class="hljs-keyword">if</span>(userAgent.indexOf(item) &gt; <span class="hljs-number">-1</span>)
                    browser = item;
            })
            <span class="hljs-keyword">if</span>(browser === <span class="hljs-string">&quot;compatible&quot;</span>) {
                <span class="hljs-keyword">if</span>(browser =userAgent.match(<span class="hljs-regexp">/(?:MSIE\s*)\d{1,2}.0(?=\s*;)/</span>)) {
                    browser = browser[<span class="hljs-number">0</span>].replace(<span class="hljs-string">&#x27;MS&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)
                }
            }
            <span class="hljs-keyword">return</span> browser;
        }             
</div></code></pre>
<hr>
<h2 id="二常用方法篇">二、常用方法篇</h2>
<h3 id="21-拷贝">2.1 拷贝</h3>
<h4 id="1-数组浅拷贝">1) 数组浅拷贝</h4>
<blockquote>
<ul>
<li>Object.assign</li>
<li></li>
</ul>
</blockquote>
<h4 id="2-数组深拷贝">2) 数组深拷贝</h4>
<blockquote>
<ul>
<li>先对输入进行判断，是数组、对象还是其他</li>
<li>然后如果是数组或者对象的时候进行遍历，子元素是数组或者对象的时候直接赋值，否则进行递归</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
         * 
         * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
         * <span class="hljs-doctag">@date    </span>2019-08-01
         * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
         */</span>

        <span class="hljs-keyword">let</span> deepCopy = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>{
            <span class="hljs-keyword">let</span> o;
            <span class="hljs-keyword">let</span> type = <span class="hljs-built_in">Object</span>.prototype.toString.call(obj);
            <span class="hljs-keyword">if</span>(type === <span class="hljs-string">&#x27;[object Array]&#x27;</span> || type === <span class="hljs-string">&#x27;[object Object]&#x27;</span>) {
                o = type === <span class="hljs-string">&#x27;[object Array]&#x27;</span> ? [] : {};
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) {
                    <span class="hljs-keyword">if</span>(obj.hasOwnProperty(key)) {
                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> obj[key] === <span class="hljs-string">&#x27;Object&#x27;</span>) {       
                    o[key] = deepCopy(obj[key]);
                }
                <span class="hljs-keyword">else</span> {
                    o[key] = obj[key];
                }
                    }
                }
            }
            <span class="hljs-keyword">else</span> {
                o = obj;
            }
            <span class="hljs-keyword">return</span> o;
        };
</div></code></pre>
<h3 id="22-类数组判断与转化">2.2 类数组判断与转化</h3>
<h4 id="1-判断">1) 判断</h4>
<blockquote>
<ul>
<li>是一个对象</li>
<li>有length属性</li>
<li>length属性的值是一个非负有限整数</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
         * 
         * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
         * <span class="hljs-doctag">@date    </span>2019-08-01
         * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
         */</span>

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isArrayLike</span>(<span class="hljs-params">obj</span>) </span>{
            <span class="hljs-keyword">return</span> obj &amp;&amp; (<span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&#x27;object&#x27;</span>) &amp;&amp;  (obj.length &gt;= <span class="hljs-number">0</span>) &amp;&amp;  obj.length &lt; <span class="hljs-number">4294967296</span> &amp;&amp; (obj.length === <span class="hljs-built_in">Math</span>.floor(obj.length))
        }
</div></code></pre>
<h4 id="2-slice的内部实现">2) slice的内部实现</h4>
<blockquote>
<ul>
<li>返回一个数组</li>
<li>循环赋值从0到length</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
         * 
         * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
         * <span class="hljs-doctag">@date    </span>2019-08-01
         * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
         */</span>

        <span class="hljs-comment">//slice的内部实现</span>
        <span class="hljs-built_in">Array</span>.prototype.slice = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">start,end</span>)</span>{  
              <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();  
              start = start || <span class="hljs-number">0</span>;  
              end = end || <span class="hljs-built_in">this</span>.length; <span class="hljs-comment">//this指向调用的对象，当用了call后，能够改变this的指向，也就是指向传进来的对象，这是关键  </span>
              <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = start; i &lt; end; i++){  
                   result.push(<span class="hljs-built_in">this</span>[i]);  
              }  
              <span class="hljs-keyword">return</span> result;  
         }
</div></code></pre>
<h4 id="3-转化">3) 转化</h4>
<blockquote>
<ul>
<li>利用slice方法 [].slice.call(a);</li>
<li>Array.from();</li>
<li>手动转化</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
         * 
         * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
         * <span class="hljs-doctag">@date    </span>2019-08-01
         * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
         */</span>

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transfer</span>(<span class="hljs-params">obj</span>) </span>{
            <span class="hljs-keyword">let</span> arr = [];
            <span class="hljs-keyword">let</span> l = obj.length;
            <span class="hljs-keyword">while</span>(l &gt; <span class="hljs-number">0</span>) arr[--l] = obj[l];
            <span class="hljs-keyword">return</span> arr;
        }
</div></code></pre>
<h3 id="24-数组乱序">2.4 数组乱序</h3>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
         * 
         * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
         * <span class="hljs-doctag">@date    </span>2019-08-01
         * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
         */</span>

        shuffle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) </span>{
            <span class="hljs-keyword">let</span> temp = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">let</span> l = arr.length;
            <span class="hljs-keyword">let</span> r = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i&lt;l; i++) {
                r = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * (i + <span class="hljs-number">1</span>));
                temp = arr[r];
                arr[r] = arr[i];
                arr[i] = temp;
            }
        }
        arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];

        shuffle(arr);
        <span class="hljs-comment">//[1, 4, 3, 5, 2, 6]</span>
</div></code></pre>
<h3 id="28-ajax封装">2.8 ajax封装</h3>
<h4 id="1-功能">1) 功能</h4>
<blockquote>
<ul>
<li></li>
<li></li>
</ul>
</blockquote>
<h3 id="29-stringformat">2.9 String.format</h3>
<h4 id="1-功能-1">1) 功能</h4>
<blockquote>
<ul>
<li>是一个函数挂载到String的原型上</li>
<li>相当于字符串模板</li>
<li>参数是模板的数据</li>
<li>分别用两个正则表达式切割关键词和非关键词，然后在进行拼接</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
         * 
         * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
         * <span class="hljs-doctag">@date    </span>2019-08-01
         * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
         */</span>

        <span class="hljs-built_in">String</span>.prototype.iFormat = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>{
            <span class="hljs-keyword">let</span> keyArray = <span class="hljs-built_in">this</span>.match(<span class="hljs-regexp">/(?&lt;=\$\{)\S+?(?=\})/g</span>);
            <span class="hljs-keyword">let</span> strArray = <span class="hljs-built_in">this</span>.split(<span class="hljs-regexp">/\$\{\S+?\}/g</span>);
            <span class="hljs-keyword">return</span> strArray.map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> data[keyArray[index]] ? item + data[keyArray[index]] : item).join(<span class="hljs-string">&#x27;&#x27;</span>);
        }

        <span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;${a}ads${a}sad${b}as${c}zx${c}&quot;</span>;
        str.iFormat({<span class="hljs-attr">a</span>: <span class="hljs-string">&#x27; I &#x27;</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27; love &#x27;</span>, <span class="hljs-attr">c</span>: <span class="hljs-string">&#x27; you &#x27;</span>}); <span class="hljs-comment">//&quot; I ads I sad love as you zx you &quot;</span>
</div></code></pre>
<h4 id="2-一个更加简介的办法利用replace">2) 一个更加简介的办法：利用replace()</h4>
<blockquote>
<ul>
<li>第二个参数可以是函数，将每匹配到的一组分组就执行一次</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
         * 
         * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
         * <span class="hljs-doctag">@date    </span>2019-08-01
         * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
         */</span>

        <span class="hljs-built_in">String</span>.prototype.iFormat = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">transfer</span>)   </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.replace(<span class="hljs-regexp">/\$\{.+?\}/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">group</span>)</span>{
                <span class="hljs-keyword">return</span> transfer[group.replace(<span class="hljs-regexp">/(^\$\{)|(\}$)/g</span>, <span class="hljs-string">&#x27;&#x27;</span>)];
            })
        }

        <span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;${a}ads${a}sad${b}as${c}zx${c}&quot;</span>;
        str.iFormat({<span class="hljs-attr">a</span>: <span class="hljs-string">&#x27; I &#x27;</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27; love &#x27;</span>, <span class="hljs-attr">c</span>: <span class="hljs-string">&#x27; you &#x27;</span>});
        <span class="hljs-comment">// &quot; I ads I sad love as you zx you &quot;</span>
</div></code></pre>
<h3 id="210-stringthousandsplit">2.10 String.thousandSplit</h3>
<h4 id="1-功能-2">1) 功能</h4>
<blockquote>
<ul>
<li>西方的数字从右往左每三位加一个分隔符</li>
</ul>
</blockquote>
<h4 id="2-实现">2) 实现</h4>
<blockquote>
<ul>
<li>需要零宽正向预言</li>
<li>$表示从右往左</li>
<li>，不能放在第一位</li>
<li>需要全局判断，因为不止匹配一个</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>            <span class="hljs-comment">/**
             * 
             * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
             * <span class="hljs-doctag">@date    </span>2019-08-01
             * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
             */</span>

            <span class="hljs-built_in">String</span>.prototype.thousandSplit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tag</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.replace(<span class="hljs-regexp">/(?&lt;=\B)(?=(\d{3})+$)/g</span>, tag);
            }

            <span class="hljs-string">&#x27;234123456&#x27;</span>.thousandSplit(<span class="hljs-string">&#x27;,&#x27;</span>);
            <span class="hljs-comment">// &quot;234,123,456&quot;</span>
            <span class="hljs-string">&#x27;1234123456&#x27;</span>.thousandSplit(<span class="hljs-string">&#x27;$&#x27;</span>);
            <span class="hljs-comment">// &quot;1$234$123$456&quot;</span>
</div></code></pre>
<hr>
<h2 id="三原理实现篇">三、原理实现篇</h2>
<h3 id="31-callapplybind">3.1 call/apply/bind</h3>
<h4 id="1-call">1) call</h4>
<blockquote>
<ul>
<li>返回一个立即执行的函数</li>
<li>该函数的作用域被绑定为第一个形参</li>
<li>其他的形参作为原函数的参数</li>
<li>模拟的方法被绑定在函数的原型上，方便调用</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
         * 
         * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
         * <span class="hljs-doctag">@date    </span>2019-08-01
         * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
         */</span>

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myCall</span>(<span class="hljs-params">fn, context = window, ...ret</span>) </span>{
            <span class="hljs-keyword">const</span> symbol = <span class="hljs-built_in">Symbol</span>();
            context[symbol] = fn;
            <span class="hljs-keyword">const</span> result = context[symbol](...ret);
            <span class="hljs-keyword">delete</span> context[symbol];
            <span class="hljs-keyword">return</span> result;
        }

</div></code></pre>
<h4 id="2-apply">2) apply</h4>
<blockquote>
<ul>
<li>根据call把参数改成数组输入的形式</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
            * 
            * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
            * <span class="hljs-doctag">@date    </span>2019-08-01
            * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
            */</span>

        <span class="hljs-built_in">Function</span>.prototype.myApply = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">content</span>) </span>{
            content.func = <span class="hljs-built_in">this</span>; <span class="hljs-comment">//转移this</span>
            <span class="hljs-keyword">return</span> content.func(...arguments[<span class="hljs-number">1</span>]);
        }

        <span class="hljs-keyword">let</span> a = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num1, num2</span>) </span>{
            <span class="hljs-built_in">this</span>.num = <span class="hljs-built_in">this</span>.num ? <span class="hljs-built_in">this</span>.num + num1 : num2;
            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.num);
        }

        <span class="hljs-keyword">let</span> b = {<span class="hljs-attr">num</span>: <span class="hljs-number">1</span>};

        a.myApply(b, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);

        <span class="hljs-comment">// 3</span>
</div></code></pre>
<h4 id="3-bind">3) bind</h4>
<blockquote>
<ul>
<li>返回一个函数</li>
<li>函数的作用域为bind的第一个参数</li>
<li>如果bind的参数不足够原函数消化，剩余的参数可以在返回的函数中输入</li>
<li>作为原型挂靠在Function上</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
            * 
            * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
            * <span class="hljs-doctag">@date    </span>2019-08-01
            * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
            */</span>

        <span class="hljs-built_in">Function</span>.prototype.myBind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">let</span> self = <span class="hljs-built_in">this</span>;
            <span class="hljs-keyword">let</span> arr1 = <span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">arguments</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">let</span> arr2 = arr1.concat(<span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">arguments</span>));
        <span class="hljs-keyword">return</span> self.call(...arr2);
            }
        }

        <span class="hljs-keyword">let</span> a = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num1, num2</span>) </span>{
            <span class="hljs-built_in">this</span>.num = <span class="hljs-built_in">this</span>.num ? <span class="hljs-built_in">this</span>.num + num1 + num2 : num2;
            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.num);
        }

        <span class="hljs-keyword">let</span> b = {<span class="hljs-attr">num</span>: <span class="hljs-number">1</span>};

        <span class="hljs-keyword">let</span> c = a.myBind(b, <span class="hljs-number">2</span>);

        c(<span class="hljs-number">3</span>);

        <span class="hljs-comment">//6</span>
        c(<span class="hljs-number">3</span>);
        <span class="hljs-number">11</span>
        c(<span class="hljs-number">3</span>);
        <span class="hljs-number">16</span>
</div></code></pre>
<h3 id="32-deferred和promise">3.2 Deferred和Promise</h3>
<h4 id="1-promisea规范">1) promise/A规范</h4>
<blockquote>
<ul>
<li>一个Promise对象有三种状态：未完成pendding，已完成Fulfilled和已拒绝Rejected</li>
<li>pendding可以转化成Fulfilled或者Rejected，但Fulfilled和Rejected不能相互转化</li>
<li>转化的过程是不可逆的</li>
<li>使用then方法可以返回promise进行链式调用</li>
<li>then方法的onFulfilled,onRejected 方法都是可选参数，且不是function，都被忽略</li>
</ul>
</blockquote>
<h4 id="2-deferredpromise">2) Deferred/promise</h4>
<blockquote>
<ul>
<li>这两个是合在一起的，这里的promise非ES6里面的Promise对象，注意这里的p是小写</li>
<li>Deferred更像是一个触发器</li>
<li>promise的then方法用来传递handlerQueue序列，handlerQueue是由每个then方法里面resolve和reject组成的handler集合</li>
<li>Deferred的resolve和reject遍历handlerQueue序列里面的handler，如果返回的结果是一个promise，就的Deferred的promise更新为返回的结果，如果不是的话就将结果作为下次resolve的实参。注意的是每遍历一个元素都需要把handlerQueue去掉相应的handler</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
            * 
            * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
            * <span class="hljs-doctag">@date    </span>2019-08-01
            * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
            */</span>

        <span class="hljs-keyword">let</span> promise = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">this</span>.handlerQueue = [];
        }

        promise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{
            <span class="hljs-keyword">let</span> handler = {};
            <span class="hljs-keyword">if</span>(resolve &amp;&amp; <span class="hljs-keyword">typeof</span> resolve === <span class="hljs-string">&#x27;function&#x27;</span>) 
        handler.resolve = resolve;
            <span class="hljs-keyword">if</span>(reject &amp;&amp; <span class="hljs-keyword">typeof</span> reject === <span class="hljs-string">&#x27;function&#x27;</span>) 
        handler.reject = reject;
            <span class="hljs-built_in">this</span>.handlerQueue.push(handler);
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
        }

        <span class="hljs-keyword">let</span> Deferred = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">this</span>.state = <span class="hljs-string">&#x27;pending&#x27;</span>;
            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.promise) {
        <span class="hljs-built_in">this</span>.promise = <span class="hljs-keyword">new</span> promise();
            }
        }

        Deferred.prototype.resolve = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>{
            <span class="hljs-built_in">this</span>.state = <span class="hljs-string">&#x27;resolve&#x27;</span>;
            <span class="hljs-keyword">let</span> handlerQueue = <span class="hljs-built_in">this</span>.promise.handlerQueue;
            <span class="hljs-keyword">let</span> res;
            <span class="hljs-keyword">let</span> handler;
            <span class="hljs-keyword">while</span>(handler = handlerQueue.shift()) {
        <span class="hljs-keyword">if</span> (handler &amp;&amp; handler.resolve) {
            res = handler.resolve(data);
            <span class="hljs-keyword">if</span> (res &amp;&amp; res <span class="hljs-keyword">instanceof</span> promise) {
                res.handlerQueue = handlerQueue;
                <span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> promise();
                p.handlerQueue = handlerQueue;
                <span class="hljs-built_in">this</span>.promise = p;
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res) {
                data = res;
            }
        }
            }
        }

        Deferred.prototype.reject = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>{
            <span class="hljs-built_in">this</span>.state = <span class="hljs-string">&#x27;reject&#x27;</span>;
            <span class="hljs-keyword">let</span> handlerQueue = <span class="hljs-built_in">this</span>.promise.handlerQueue;
            <span class="hljs-keyword">let</span> res;
            <span class="hljs-keyword">let</span> handler;
            <span class="hljs-keyword">while</span>(handler = handlerQueue.shift()) {
        <span class="hljs-keyword">if</span> (handler &amp;&amp; handler.reject) {
            res = handler.reject(data);
            <span class="hljs-keyword">if</span> (res &amp;&amp; res <span class="hljs-keyword">instanceof</span> promise) {
                res.handlerQueue = handlerQueue;
                <span class="hljs-built_in">this</span>.promise = res;
                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 这里还是有问题，如果返回的是一个promise会直接中断运行</span>
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res) {
                data = res;
            }
        }
            }
        }

        <span class="hljs-comment">//------ test-------//</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncDosomeing</span>(<span class="hljs-params">flag, name</span>) </span>{
            <span class="hljs-keyword">const</span> deferred = <span class="hljs-keyword">new</span> Deferred()
            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (flag) {
            deferred.resolve({<span class="hljs-attr">code</span>: <span class="hljs-number">200</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;成功&#x27;</span>, <span class="hljs-attr">name</span>: name})
        } <span class="hljs-keyword">else</span> {
            deferred.reject({<span class="hljs-attr">code</span>: <span class="hljs-number">400</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;失败&#x27;</span>, <span class="hljs-attr">name</span>: name})
        }
            }, <span class="hljs-number">2000</span>)
            <span class="hljs-keyword">return</span> deferred.promise
        }
        asyncDosomeing(<span class="hljs-literal">true</span>, <span class="hljs-string">&#x27;asyncDosomeing1&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {
            <span class="hljs-built_in">console</span>.info(result)
            <span class="hljs-keyword">return</span> asyncDosomeing(<span class="hljs-literal">false</span>, <span class="hljs-string">&#x27;asyncDosomeing2&#x27;</span>)
        }).then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {
            <span class="hljs-built_in">console</span>.info(result)
            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;dadds&#x27;</span>
        }).then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {
            <span class="hljs-built_in">console</span>.info(result)
        })
</div></code></pre>
<h4 id="2-promise第一次自己写的">2) Promise(第一次自己写的)</h4>
<blockquote>
<ul>
<li>Promise是Deferred/promise的混合版</li>
<li>Promise既作触发器又做储存器</li>
<li>需要在resolve和reject上包装，已达到窃听的效果</li>
<li>实现resolve和reject原型方法</li>
<li>如果返回值是空类型，则正常返回this作链式调用，如果返回值非空也非Promise类型，则作为参数传到下一个then，可惜这个我实现不了</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
            * 
            * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
            * <span class="hljs-doctag">@date    </span>2019-08-01
            * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
            */</span>
        <span class="hljs-keyword">let</span> MyPromise = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) </span>{
            <span class="hljs-built_in">this</span>.status = <span class="hljs-string">&#x27;unfulfilled&#x27;</span>;
            <span class="hljs-built_in">this</span>.fn = <span class="hljs-keyword">typeof</span> fn === <span class="hljs-string">&#x27;function&#x27;</span> ? fn : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{};
            <span class="hljs-built_in">this</span>.resolve = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">func</span>) </span>{
            <span class="hljs-keyword">let</span> newPromise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(func);
            newPromise.status = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;
            <span class="hljs-keyword">return</span> newPromise;
            }

            <span class="hljs-built_in">this</span>.reject = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">func</span>) </span>{
            <span class="hljs-keyword">let</span> newPromise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(func);
            newPromise.status = <span class="hljs-string">&#x27;failed&#x27;</span>;
            <span class="hljs-keyword">return</span> newPromise;
            }
        }
        MyPromise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{
            <span class="hljs-keyword">let</span> self = <span class="hljs-built_in">this</span>;
            <span class="hljs-built_in">this</span>.resolve = resolve;
            <span class="hljs-built_in">this</span>.reject = reject;
            <span class="hljs-keyword">let</span> _resolve = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>) </span>{
        self.status = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;
        resolve(a);
            }
            <span class="hljs-keyword">let</span> _reject = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>) </span>{
        self.status = <span class="hljs-string">&#x27;failed&#x27;</span>;
        reject(a);
            }
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === <span class="hljs-string">&#x27;unfulfilled&#x27;</span>) 
            <span class="hljs-built_in">this</span>.fn(_resolve, _reject);
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === <span class="hljs-string">&#x27;fulfilled&#x27;</span>) 
            <span class="hljs-built_in">this</span>.fn(resolve);
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === <span class="hljs-string">&#x27;failed&#x27;</span>) 
            <span class="hljs-built_in">this</span>.fn(reject);
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
        }

        p = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">if</span> (value &lt; <span class="hljs-number">10</span>) {
                resolve(value);
            }
            <span class="hljs-keyword">else</span> {
                reject(value);
            }
        }, <span class="hljs-number">1000</span>)
            })
        }
        p(<span class="hljs-number">9</span>)
        .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;fulfilled = &#x27;</span>, data);
            }, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;unfulfilled = &#x27;</span>, data);
            })
        .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;transfer..&#x27;</span>);
        <span class="hljs-keyword">return</span> data + <span class="hljs-number">10</span>;
            })
        .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;fulfilled = &#x27;</span>, data);
            }, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;unfulfilled = &#x27;</span>, data);
            })
        MyPromise.resolve(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            resolve(<span class="hljs-string">&#x27;i love you&#x27;</span>);
            }, <span class="hljs-number">1000</span>)
        }).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;fulfilled = &#x27;</span>, data);
            })
</div></code></pre>
<h4 id="3-promise看了别人代码后自己写的">3) Promise(看了别人代码后自己写的)</h4>
<blockquote>
<ul>
<li>为了支持同步的Promise，采用异步调用_resolve和_reject</li>
<li>then方法比较复杂，首先返回的是一个promise，然后根据不同的返回值类型进行进一步处理</li>
<li>function(cal) {try {resolve(val) or reject(val)} catch(e) {reject(e)}}</li>
<li>catch是唯一没有可能返回promise的函数</li>
<li>resolve和reject方法就是返回一个仅有resolve或者reject方法的promise，同时resolve方法将判断参数的类型，如果参数是非promise类型，将会把它包装成promise类型</li>
<li>all方法是返回一个promise，循环得到结果放到一个数组中，由于每个子项执行的时间不一致，只能新建计数器来统计then执行的次数，当计数器等于all的数组参数个数的时候才进行resolve的统一处理结果数组</li>
<li>race方法是返回一个promise，遍历所有的promise数组，不需要搜集结果</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
            * 
            * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
            * <span class="hljs-doctag">@date    </span>2019-08-01
            * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
            */</span>

        <span class="hljs-comment">// 定义状态常量</span>
        <span class="hljs-keyword">const</span> PENDDING = <span class="hljs-string">&#x27;pendding&#x27;</span>;
        <span class="hljs-keyword">const</span> FULFILLED = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;
        <span class="hljs-keyword">const</span> UNFULFILLED = <span class="hljs-string">&#x27;unfulfilled&#x27;</span>;

        <span class="hljs-comment">// 判断是否是函数类型</span>
        <span class="hljs-keyword">let</span> isFunction = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">func</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> func === <span class="hljs-string">&#x27;function&#x27;</span>
        };

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span> </span>{

            <span class="hljs-keyword">constructor</span>(handle) {

        <span class="hljs-comment">// 判断handle是否是函数</span>
        <span class="hljs-keyword">if</span> (!isFunction(handle)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Your handle is not function!&#x27;</span>)
        }

        <span class="hljs-comment">// 定义初始状态</span>
        <span class="hljs-built_in">this</span>._status = PENDDING;

        <span class="hljs-comment">// 定义每次执行函数的参数</span>
        <span class="hljs-built_in">this</span>._value = <span class="hljs-literal">undefined</span>;

        <span class="hljs-comment">// 定义resolve队列和reject，用于链式调用</span>
        <span class="hljs-built_in">this</span>._resolveQueue = [];
        <span class="hljs-built_in">this</span>._rejectQueue = [];

        <span class="hljs-comment">// 执行handle;</span>
        <span class="hljs-keyword">try</span> {
            handle(<span class="hljs-built_in">this</span>._resolve.bind(<span class="hljs-built_in">this</span>), <span class="hljs-built_in">this</span>._reject.bind(<span class="hljs-built_in">this</span>));
        }
        <span class="hljs-keyword">catch</span>(err) {
            <span class="hljs-built_in">this</span>._reject(err);
        }
            }

            <span class="hljs-comment">// 添加resolve时执行的函数</span>
            _resolve(val) {

        <span class="hljs-comment">// 判断此时的状态，如果是非PENDDING状态就直接结束</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>._status !== PENDDING) <span class="hljs-keyword">return</span>;

        <span class="hljs-keyword">let</span> run = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-comment">// 执行队列</span>
            <span class="hljs-keyword">let</span> execQueue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">queue, argu</span>) </span>{
                <span class="hljs-keyword">let</span> exec;
                <span class="hljs-keyword">while</span>(exec = queue.shift()) {
                    exec(argu);
                }
            }

            <span class="hljs-comment">// 判断val是否是MyPromise类型</span>
            <span class="hljs-comment">// 如果val是MyPromise类型则执行它</span>
            <span class="hljs-comment">// 如果val不是MyPromise类型则</span>
            <span class="hljs-keyword">if</span> (val <span class="hljs-keyword">instanceof</span> MyPromise) {
                val.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
                    <span class="hljs-built_in">this</span>._value = value;
                    <span class="hljs-built_in">this</span>._status = FULFILLED;
                    execQueue(<span class="hljs-built_in">this</span>._resolveQueue, <span class="hljs-built_in">this</span>._value);
                }, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
                    <span class="hljs-built_in">this</span>._value = error;
                    <span class="hljs-built_in">this</span>._status = UNFULFILLED;
                    execQueue(<span class="hljs-built_in">this</span>._rejectQueue, <span class="hljs-built_in">this</span>._value);
                })
            }
            <span class="hljs-keyword">else</span> {
                <span class="hljs-built_in">this</span>._value = val;
                <span class="hljs-built_in">this</span>._status = FULFILLED;
                execQueue(<span class="hljs-built_in">this</span>._resolveQueue, <span class="hljs-built_in">this</span>._value);
            }
        }

        <span class="hljs-comment">// 为了支持同步的Promise，这里采用异步调用</span>
        <span class="hljs-built_in">setTimeout</span>(run.bind(<span class="hljs-built_in">this</span>), <span class="hljs-number">0</span>);
            }  

            <span class="hljs-comment">// 添加reject时执行的函数</span>
            <span class="hljs-comment">// 此时不需要判断参数类型是否是MyPromise类型</span>
            _reject(error) {

        <span class="hljs-comment">// 判断此时的状态，如果是非PENDDING状态就直接结束</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>._status !== PENDDING) <span class="hljs-keyword">return</span>;

        <span class="hljs-keyword">let</span> run = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-comment">// 执行队列</span>
            <span class="hljs-keyword">let</span> execQueue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">queue, argu</span>) </span>{
                <span class="hljs-keyword">let</span> exec;
                <span class="hljs-keyword">while</span>(exec = queue.shift()) {
                    exec(argu);
                }
            }

            <span class="hljs-built_in">this</span>._value = error;
            <span class="hljs-built_in">this</span>._status = UNFULFILLED;
            execQueue(<span class="hljs-built_in">this</span>._rejectQueue, <span class="hljs-built_in">this</span>._value);
        }

        <span class="hljs-comment">// 异步执行</span>
        <span class="hljs-built_in">setTimeout</span>(run.bind(<span class="hljs-built_in">this</span>), <span class="hljs-number">0</span>);
            }

            <span class="hljs-comment">// 添加then方法 用于承上启下</span>
            <span class="hljs-comment">// 当状态是PENDDING时保存每个状态的方法到相应队列</span>
            <span class="hljs-comment">// 返回的是一个MyPromise</span>
            then(onFulfilled, onRejected) {
        <span class="hljs-comment">// 初始化变量</span>
        <span class="hljs-keyword">const</span> _value = <span class="hljs-built_in">this</span>._value;
        <span class="hljs-keyword">const</span> _status = <span class="hljs-built_in">this</span>._status;

        <span class="hljs-comment">// onFulfilledNext, onRejectedNext为下一个then中的回调函数</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">onFulfilledNext, onRejectedNext</span>) =&gt;</span> {

            <span class="hljs-comment">// 封装一个可以执行一系列判断的onFulfilled</span>
            <span class="hljs-keyword">let</span> fulfilled = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_value</span>) </span>{
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-keyword">if</span>(isFunction(onFulfilled)) {  <span class="hljs-comment">//判断onFulfilled是否是函数</span>
                <span class="hljs-keyword">let</span> res = onFulfilled(_value);
                <span class="hljs-keyword">if</span>(res <span class="hljs-keyword">instanceof</span> MyPromise) { <span class="hljs-comment">// 假如res是一个MyPromise类型，则需要等res执行完毕才能跳到下一个状态</span>
                    res.then(onFulfilledNext, onRejectedNext);
                }
                <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 假如res不是一个MyPromise类型，则作为下一个then中回调函数中的参数</span>
                    onFulfilledNext(res);
                }
                    }
                    <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 如果onFulfilled不是函数</span>
                onRejectedNext(_value);
                    }
                }
                <span class="hljs-keyword">catch</span> (err) {
                    onRejectedNext(err);
                }
            }

            <span class="hljs-comment">// 封装一个可以执行一系列判断的onRejected</span>
            <span class="hljs-keyword">let</span> rejected = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_value</span>) </span>{
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-keyword">if</span>(isFunction(onRejected)) { <span class="hljs-comment">// 如果onRejected是函数</span>
                <span class="hljs-keyword">let</span> res = onRejected(_value); 
                <span class="hljs-keyword">if</span>(res <span class="hljs-keyword">instanceof</span> MyPromise) { <span class="hljs-comment">// 假如res是一个MyPromise类型，则需要等res执行完毕才能跳到下一个状态</span>
                    res.then(onFulfilledNext, onRejectedNext);
                }
                <span class="hljs-keyword">else</span> {  <span class="hljs-comment">// 假如res不是一个MyPromise类型，则作为下一个then中回调函数中的参数</span>
                    onFulfilledNext(res);
                }
                    }
                    <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 如果onRejected不是函数</span>
                onRejectedNext(_value);
                    }
                }
                <span class="hljs-keyword">catch</span> (err) {
                    onRejectedNext(err);
                }
            }

            <span class="hljs-comment">// 判断_status的状态才决定执行怎样的处理函数</span>
            <span class="hljs-keyword">switch</span> (_status) {
                <span class="hljs-keyword">case</span> PENDDING: <span class="hljs-comment">// 如果是PENNDING的话把onFulfilled和onRejected保存到队列中</span>
                    <span class="hljs-built_in">this</span>._resolveQueue.push(fulfilled);
                    <span class="hljs-built_in">this</span>._rejectQueue.push(rejected);
                    <span class="hljs-keyword">break</span>
                <span class="hljs-keyword">case</span> FULFILL: <span class="hljs-comment">// 如果是FULFILL状态，则马上执行onFulfilled</span>
                    fulfilled(_value);
                    <span class="hljs-keyword">break</span>   
                <span class="hljs-keyword">case</span> UNFULFILL:  <span class="hljs-comment">// 如果是UNFULFILL状态，则马上执行onRejected</span>
                    rejected(_value);
                    <span class="hljs-keyword">break</span>
            }
        })
            }
            <span class="hljs-keyword">static</span> resolve(val) {
        <span class="hljs-keyword">return</span> val <span class="hljs-keyword">instanceof</span> MyPromise ? val : <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
            resolve(val);
            })
            }
            <span class="hljs-keyword">static</span> reject(err) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
            reject(err);
        })
            }

            <span class="hljs-keyword">static</span> <span class="hljs-keyword">catch</span>(rejected) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(<span class="hljs-literal">undefined</span>, rejected);
            }

            <span class="hljs-keyword">static</span> all(promiseArr) {
        <span class="hljs-keyword">let</span> res = [];
        <span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
            promiseArr.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
                <span class="hljs-built_in">this</span>.resolve(item).then(<span class="hljs-function"><span class="hljs-params">argu</span> =&gt;</span> {
                    res.push(argu);
                    num++;
                    <span class="hljs-keyword">if</span> (num === promiseArr.length)
                resolve(res)
                }, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> reject(error))
            })
        });
            }

            <span class="hljs-keyword">static</span> race(promiseArr) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
            promiseArr.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
                <span class="hljs-built_in">this</span>.resolve(item).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> resolve(res), <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> reject(err));
            })
        })
            }
        }

        p = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">if</span> (value &lt; <span class="hljs-number">10</span>) {
                resolve(value);
            }
            <span class="hljs-keyword">else</span> {
                reject(value);
            }
        }, <span class="hljs-number">1000</span>)
            })
        }

        p(<span class="hljs-number">9</span>)
        .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;fulfilled = &#x27;</span>, data);
        <span class="hljs-keyword">return</span> data;
            }, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;unfulfilled = &#x27;</span>, data);
            })
        .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;transfer..&#x27;</span>);
        <span class="hljs-keyword">return</span> p(data + <span class="hljs-number">10</span>);
            })
        .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;fulfilled = &#x27;</span>, data);
            }, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;unfulfilled = &#x27;</span>, data);
            })

        <span class="hljs-comment">// 结果</span>
        fulfilled =  <span class="hljs-number">9</span>
        <span class="hljs-attr">VM17445</span>:<span class="hljs-number">9</span> transfer..
        VM17445:<span class="hljs-number">15</span> unfulfilled =  <span class="hljs-number">19</span>

        <span class="hljs-keyword">let</span> pTime = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, delay</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">if</span> (value &lt; <span class="hljs-number">10</span>) {
                resolve(value);
            }
            <span class="hljs-keyword">else</span> {
                reject(value);
            }
        }, delay)
            })
        }

        MyPromise.race([pTime(<span class="hljs-number">9</span>, <span class="hljs-number">5000</span>), pTime(<span class="hljs-number">8</span>, <span class="hljs-number">3000</span>), pTime(<span class="hljs-number">7</span>, <span class="hljs-number">1000</span>)]).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;fulfilled = &#x27;</span>, data);
        }, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;unfulfilled = &#x27;</span>, data);
        }) 

        <span class="hljs-comment">//fulfilled =  7</span>

        MyPromise.race([pTime(<span class="hljs-number">18</span>, <span class="hljs-number">5000</span>), pTime(<span class="hljs-number">19</span>, <span class="hljs-number">3000</span>), pTime(<span class="hljs-number">20</span>, <span class="hljs-number">1000</span>)]).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;fulfilled = &#x27;</span>, data);
        }, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;unfulfilled = &#x27;</span>, data);
        })

        <span class="hljs-comment">// unfulfilled =  20</span>

        MyPromise.all([pTime(<span class="hljs-number">7</span>, <span class="hljs-number">5000</span>), pTime(<span class="hljs-number">8</span>, <span class="hljs-number">3000</span>), pTime(<span class="hljs-number">9</span>, <span class="hljs-number">1000</span>)]).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;fulfilled = &#x27;</span>, data);
        }, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;unfulfilled = &#x27;</span>, data);
        })

        <span class="hljs-comment">// fulfilled =  (3) [9, 8, 7]</span>
</div></code></pre>
<h3 id="34-观察者模式">3.4 观察者模式</h3>
<h4 id="1-要点">1) 要点</h4>
<blockquote>
<ul>
<li>监听器listener：其实是一系列的函数</li>
<li>监听器类型: type</li>
<li>监听器注册表：</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-keyword">let</span> _registers = [
                    {
                        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;&#x27;</span>,
                        <span class="hljs-attr">listener</span>: <span class="hljs-string">&#x27;&#x27;</span>
                    },
                    ...
                ]
</div></code></pre>
<blockquote>
<ul>
<li>监听器列表：</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        
        <span class="hljs-keyword">let</span> _listeners = {
            <span class="hljs-attr">type1</span>: [
                    listener1,
                    listener2,
                    ...
            ],
            <span class="hljs-attr">type2</span>: [
                    listener1,
                    listener2,
                    ...
            ],
            ...
        }
</div></code></pre>
<blockquote>
<ul>
<li>建立一个类</li>
</ul>
<blockquote>
<ul>
<li>原型变量:注册表和监听器列表</li>
<li>原型方法：添加/删除 某类型的监听器</li>
</ul>
</blockquote>
</blockquote>
<h4 id="2-代码">2) 代码</h4>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
         * 
         * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
         * <span class="hljs-doctag">@date    </span>2019-08-01
         * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
         */</span>

        <span class="hljs-keyword">let</span> Listen = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

        }
        Listen.prototype = {
            <span class="hljs-attr">_listeners</span>: {},
            <span class="hljs-attr">_registers</span>: [],
            <span class="hljs-attr">addListener</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, listener</span>) </span>{
                <span class="hljs-built_in">this</span>._listeners[type] = <span class="hljs-built_in">this</span>._listeners[type] ? <span class="hljs-built_in">this</span>._listeners[type] : [];
                <span class="hljs-built_in">this</span>._listeners[type].push(listener);
            },
            <span class="hljs-attr">removeListener</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, listener</span>) </span>{
                <span class="hljs-keyword">let</span> index = <span class="hljs-built_in">this</span>._listeners[type].indexOf(listener);
                <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) {
                    <span class="hljs-built_in">this</span>._listeners[type].splice(index,index+<span class="hljs-number">1</span>);
                }
            },
            <span class="hljs-attr">register</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, listener</span>) </span>{
                <span class="hljs-built_in">this</span>._registers.push(
                    {
                <span class="hljs-attr">type</span>: type,
                <span class="hljs-attr">listener</span>: listener
                    }
                )
            },
            <span class="hljs-attr">trigger</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, var_args</span>) </span>{
                <span class="hljs-keyword">let</span> funcs = <span class="hljs-built_in">this</span>._listeners[type];
                <span class="hljs-keyword">let</span> args = [].slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);
                <span class="hljs-keyword">return</span> funcs.map(<span class="hljs-function"><span class="hljs-params">func</span> =&gt;</span> func.apply(<span class="hljs-built_in">this</span>, args));
            }
        }
        Listen.prototype.contructor = Listen;
</div></code></pre>
<h3 id="35-防抖动和截流">3.5 防抖动和截流</h3>
<h4 id="1-相同点">1) 相同点</h4>
<blockquote>
<ul>
<li>防止用户频繁的操作造成阻塞或者屏幕抖动，提升用户体验</li>
<li>提升性能</li>
</ul>
</blockquote>
<h4 id="2-不同点">2) 不同点</h4>
<blockquote>
<ul>
<li>防抖动是发生在操作与操作之间的时间空隙，拉长操作之间的延迟时间</li>
<li>截流是指在连续重复的操作中，保证每次的操作时间周期，一般比操作实际运行的时间要长</li>
</ul>
</blockquote>
<h4 id="3-防抖动">3) 防抖动</h4>
<blockquote>
<ul>
<li>最多存活一个，可能是第一个也有可能是最后一个</li>
<li>需要用到setTimeout</li>
<li>用bounce对回调函数进行包装</li>
<li>注意setTimeout和的作用域：内部延迟执行的代码中的this永远指向window，但是回调函数本身的this可以指向其他，所以setTimeout需要先在全局进行定义。</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
         * 
         * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
         * <span class="hljs-doctag">@date    </span>2019-08-01
         * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">cb, delay, isImmediate</span>) </span>{
            <span class="hljs-keyword">let</span> timer; <span class="hljs-comment">//   利用闭包设置定时器，同时肩负是否立即执行的状态</span>
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...ret</span>) </span>{ <span class="hljs-comment">// 返回函数</span>
        <span class="hljs-keyword">if</span> (isImmediate) {
            <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);
            <span class="hljs-keyword">else</span> cb(...ret);
            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                timer = <span class="hljs-literal">null</span>;
            }, delay)
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);
            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{cb(...ret);}, delay)
        }
            }
        }

        a = debounce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-built_in">console</span>.log(<span class="hljs-number">123</span>)}, <span class="hljs-number">2000</span>, <span class="hljs-literal">true</span>);
        <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, a);
</div></code></pre>
<h4 id="4-截流频率控制">4) 截流/频率控制</h4>
<blockquote>
<ul>
<li>需要比较实际运行时间长度和设定的周期时间</li>
<li>立即执行，无需使用setTimeout</li>
<li>如果实际运行时间长度 &gt; 设定的周期时间, 则运行回调，并且把当前时间戳设为旧时间戳；</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
         * 
         * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
         * <span class="hljs-doctag">@date    </span>2019-08-01
         * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">cb, delay, isImmediate</span>) </span>{
            <span class="hljs-keyword">let</span> timer; <span class="hljs-comment">//   利用闭包设置定时器，同时肩负是否立即执行的状态</span>
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...ret</span>) </span>{ <span class="hljs-comment">// 返回函数</span>
        <span class="hljs-keyword">if</span> (isImmediate) {
            <span class="hljs-keyword">if</span> (!timer) {
                cb(...ret);
                timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    timer = <span class="hljs-literal">null</span>;
                }, delay);
            }
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (!timer) {
                timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    cb(...ret);
                    timer = <span class="hljs-literal">null</span>;
                }, delay);
            }
        }
            }
        }

        a = throttle(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-built_in">console</span>.log(<span class="hljs-number">123</span>)}, <span class="hljs-number">2000</span>, <span class="hljs-literal">true</span>);
        <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, a);
</div></code></pre>
<h4 id="5-防抖动和截流合并">5) 防抖动和截流合并</h4>
<blockquote>
<ul>
<li>在截流里面把防抖动的函数写进去</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
         * 
         * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
         * <span class="hljs-doctag">@date    </span>2019-08-01
         * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
         */</span>

        <span class="hljs-keyword">let</span> old = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
        <span class="hljs-keyword">let</span> myTimer;
        <span class="hljs-keyword">let</span> bounceAndThrottle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cycleTime, delayTime, callback</span>) </span>{
            <span class="hljs-keyword">let</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
            <span class="hljs-keyword">if</span> (now - old &gt; cycleTime) {
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Flow。。。&#x27;</span>);
                <span class="hljs-built_in">clearTimeout</span>(myTimer);
                myTimer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">if</span>(callback) callback()
                    }, delayTime);
                old = now;
            }
        }

        <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            debounceAndThrottle(<span class="hljs-number">3000</span>, <span class="hljs-number">5000</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;i am working&#x27;</span>);
                });
        });
</div></code></pre>
<h3 id="36-类的继承">3.6 类的继承</h3>
<h4 id="1-属性拷贝">1) 属性拷贝</h4>
<blockquote>
<ul>
<li>这是最简单的，把父类的属性全都拷贝一份</li>
</ul>
</blockquote>
<h4 id="2-原型式继承">2) 原型式继承</h4>
<blockquote>
<ul>
<li>只能继承父构造函数的原型对象上的成员, 不能继承父构造函数的实例对象的成员</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
         * 
         * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
         * <span class="hljs-doctag">@date    </span>2019-08-01
         * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
         */</span>

        <span class="hljs-comment">// 父类</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">age</span>) </span>{
            <span class="hljs-built_in">this</span>.age = age;
            <span class="hljs-built_in">this</span>.friends = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>];
        }
        Parent.prototype.name = [<span class="hljs-string">&#x27;lvweiyaun&#x27;</span>];
        Parent.prototype.tellName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);
        }

        <span class="hljs-comment">// 子类</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">sex</span>) </span>{
            <span class="hljs-built_in">this</span>.sex = sex;
        }
        Child.prototype = Parent.prototype;
        Child.prototype.constructor = Child;
        <span class="hljs-keyword">let</span> child1 = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">&#x27;male&#x27;</span>);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child1.name = &#x27;</span>, child1.name);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child1.friends = &#x27;</span>, child1.friends);

        <span class="hljs-comment">// child1.name =  [&quot;lvweiyaun&quot;]</span>
        <span class="hljs-comment">// undefined</span>
</div></code></pre>
<h4 id="3-原型链继承">3) 原型链继承</h4>
<blockquote>
<ul>
<li>将父类的公有和私有属性和公有方法都继承过来的</li>
<li>优点：直接把父类的原型（浅）拷贝过来，简单易用</li>
<li>缺点</li>
</ul>
<blockquote>
<ul>
<li>新实例无法向父类构造函数传参</li>
<li>存在父类私有引用类型属性共享的问题</li>
</ul>
</blockquote>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
         * 
         * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
         * <span class="hljs-doctag">@date    </span>2019-08-01
         * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
         */</span>

        <span class="hljs-comment">// 父类</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">age</span>) </span>{
            <span class="hljs-built_in">this</span>.age = age;
            <span class="hljs-built_in">this</span>.friends = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>];
        }
        Parent.prototype.name = [<span class="hljs-string">&#x27;lvweiyaun&#x27;</span>];
        Parent.prototype.tellName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);
        }

        <span class="hljs-comment">// 子类</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">sex</span>) </span>{
            <span class="hljs-built_in">this</span>.sex = sex;
        }
        Child.prototype = <span class="hljs-keyword">new</span> Parent(<span class="hljs-number">50</span>);
        Child.prototype.constructor = Child;
        <span class="hljs-keyword">let</span> child1 = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">&#x27;male&#x27;</span>);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child1.friends = &#x27;</span>, child1.friends);
        <span class="hljs-keyword">let</span> child2 = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">&#x27;female&#x27;</span>);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child2.friends = &#x27;</span>, child2.friends);
        child2.friends.push(<span class="hljs-string">&#x27;lvhongbin&#x27;</span>);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child2.friends = &#x27;</span>, child2.friends);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child1.friends = &#x27;</span>, child1.friends);

        <span class="hljs-comment">// child1.friends =  [&quot;a&quot;, &quot;b&quot;]</span>
        <span class="hljs-comment">// child2.friends =  [&quot;a&quot;, &quot;b&quot;]</span>
        <span class="hljs-comment">// child2.friends =  [&quot;a&quot;, &quot;b&quot;, &quot;lvhongbin&quot;]</span>
        <span class="hljs-comment">// child1.friends =  [&quot;a&quot;, &quot;b&quot;, &quot;lvhongbin&quot;]</span>
</div></code></pre>
<h4 id="4-构造函数继承">4) 构造函数继承</h4>
<blockquote>
<ul>
<li>使用call继承父类的构造函数</li>
<li>好处：可以得到父类的构造函数属性，向父类构造函数传参。</li>
<li>坏处：无法得到父类的原型属性</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
         * 
         * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
         * <span class="hljs-doctag">@date    </span>2019-08-01
         * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
         */</span>
        <span class="hljs-comment">// 父类</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">age</span>) </span>{
            <span class="hljs-built_in">this</span>.age = age;
        }
        Parent.prototype.name = [<span class="hljs-string">&#x27;lvweiyaun&#x27;</span>];
        Parent.prototype.tellName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);
        }

        <span class="hljs-comment">// 子类</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">sex, age</span>) </span>{
            Parent.call(<span class="hljs-built_in">this</span>, age);
            <span class="hljs-built_in">this</span>.sex = sex;
        }
        <span class="hljs-keyword">let</span> child1 = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">&#x27;male&#x27;</span>, <span class="hljs-number">20</span>);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child1.name = &#x27;</span>, child1.name);
        <span class="hljs-keyword">let</span> child2 = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">&#x27;female&#x27;</span>, <span class="hljs-number">22</span>);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child2.name = &#x27;</span>, child2.name);
        child2.name.push(<span class="hljs-string">&#x27;lvhongbin&#x27;</span>);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child2.name = &#x27;</span>, child2.name);
        <span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> Parent(<span class="hljs-number">55</span>);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;p.name = &#x27;</span>, p.name);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child1.name = &#x27;</span>, child1.name);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child1.age = &#x27;</span>, child1.age);


        <span class="hljs-comment">// child1.name =  undefined</span>
        <span class="hljs-comment">// child2.name =  undefined</span>
        <span class="hljs-comment">// error!</span>
        p.name =  [<span class="hljs-string">&quot;lvweiyaun&quot;</span>]
        <span class="hljs-comment">// child1.name =  undefined</span>
        child1.age =  <span class="hljs-number">20</span>
</div></code></pre>
<h4 id="5-组合继承">5) 组合继承</h4>
<blockquote>
<ul>
<li>原型链继承 + 构造函数继承</li>
<li>解决了对象共享的问题，还能拿到父类的构造函数</li>
<li>但是存在性能问题，因为父类有两次构造</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
         * 
         * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
         * <span class="hljs-doctag">@date    </span>2019-08-01
         * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
         */</span>
        <span class="hljs-comment">// 父类</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">age</span>) </span>{
            <span class="hljs-built_in">this</span>.age = age;
            <span class="hljs-built_in">this</span>.friends = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>];
        }

        Parent.prototype.name = [<span class="hljs-string">&#x27;lvweiyaun&#x27;</span>];
        Parent.prototype.tellName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);
        }

        <span class="hljs-comment">// 子类</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">sex, age</span>) </span>{
            Parent.call(<span class="hljs-built_in">this</span>, age);
            <span class="hljs-built_in">this</span>.sex = sex;
        }
        Child.prototype = <span class="hljs-keyword">new</span> Parent(<span class="hljs-number">50</span>);
        Child.prototype.constructor = Child;
        <span class="hljs-keyword">let</span> child1 = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">&#x27;male&#x27;</span>, <span class="hljs-number">20</span>);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child1.name = &#x27;</span>, child1.name);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child1.friends = &#x27;</span>, child1.friends);
        <span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> Parent(<span class="hljs-number">55</span>);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;p.name = &#x27;</span>, p.name);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child1.name = &#x27;</span>, child1.name);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child1.age = &#x27;</span>, child1.age);


        <span class="hljs-comment">// child1.name =  [&quot;lvweiyaun&quot;]</span>
        <span class="hljs-comment">// child1.friends =  [&quot;a&quot;, &quot;b&quot;]</span>
        <span class="hljs-comment">// p.name =  [&quot;lvweiyaun&quot;]</span>
        <span class="hljs-comment">// child1.name =  [&quot;lvweiyaun&quot;]</span>
        <span class="hljs-comment">// child1.age =  20</span>
</div></code></pre>
<h4 id="6-组合继承优化1">6) 组合继承优化1</h4>
<blockquote>
<ul>
<li>原型式继承 + 构造函数继承</li>
<li>解决了对象共享的问题，还能拿到父类的构造函数</li>
<li>不存在性能问题</li>
<li>但是子类无法修改原型的constructor属性，因为一旦修改就会同时修改父类的constructor属性，换句话说无法辨别子类的构造函数是谁</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
         * 
         * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
         * <span class="hljs-doctag">@date    </span>2019-08-01
         * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
         */</span>
        <span class="hljs-comment">// 父类</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">age</span>) </span>{
            <span class="hljs-built_in">this</span>.age = age;
            <span class="hljs-built_in">this</span>.friends = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>];
        }
        Parent.prototype.name = [<span class="hljs-string">&#x27;lvweiyaun&#x27;</span>];
        Parent.prototype.tellName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);
        }

        <span class="hljs-comment">// 子类</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">sex, age</span>) </span>{
            Parent.call(<span class="hljs-built_in">this</span>, age);
            <span class="hljs-built_in">this</span>.sex = sex;
        }
        Child.prototype = Parent.prototype;
        Child.prototype.constructor = Child;
        
        <span class="hljs-keyword">let</span> child1 = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">&#x27;male&#x27;</span>, <span class="hljs-number">20</span>);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child1.name = &#x27;</span>, child1.name);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child1.friends = &#x27;</span>, child1.friends);
        <span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> Parent(<span class="hljs-number">55</span>);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;p.name = &#x27;</span>, p.name);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child1.name = &#x27;</span>, child1.name);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child1.age = &#x27;</span>, child1.age);
        p <span class="hljs-keyword">instanceof</span> Child;


        <span class="hljs-comment">// child1.name =  [&quot;lvweiyaun&quot;]</span>
        <span class="hljs-comment">// child1.friends =  [&quot;a&quot;, &quot;b&quot;]</span>
        <span class="hljs-comment">// p.name =  [&quot;lvweiyaun&quot;]</span>
        <span class="hljs-comment">// child1.name =  [&quot;lvweiyaun&quot;]</span>
        <span class="hljs-comment">// child1.age =  20</span>
        <span class="hljs-comment">// true</span>
</div></code></pre>
<h4 id="7-组合继承优化2">7) 组合继承优化2</h4>
<blockquote>
<ul>
<li>目前来讲比较完美的方法</li>
<li>使用寄生式组合继承</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">// 父类</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">age</span>) </span>{
            <span class="hljs-built_in">this</span>.age = age;
            <span class="hljs-built_in">this</span>.friends = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>];
        }
        Parent.prototype.name = [<span class="hljs-string">&#x27;lvweiyaun&#x27;</span>];
        Parent.prototype.tellName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);
        }

        <span class="hljs-comment">// 子类</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">sex, age</span>) </span>{
            Parent.call(<span class="hljs-built_in">this</span>, age);
            <span class="hljs-built_in">this</span>.sex = sex;
        }
        Child.prototype = <span class="hljs-built_in">Object</span>.create(Parent.prototype);
        Child.prototype.constructor = Child;

        <span class="hljs-keyword">let</span> child1 = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">&#x27;male&#x27;</span>, <span class="hljs-number">20</span>);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child1.name = &#x27;</span>, child1.name);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child1.friends = &#x27;</span>, child1.friends);
        <span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> Parent(<span class="hljs-number">55</span>);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;p.name = &#x27;</span>, p.name);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child1.name = &#x27;</span>, child1.name);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child1.age = &#x27;</span>, child1.age);
        p <span class="hljs-keyword">instanceof</span> Child;

        <span class="hljs-comment">// child1.name =  [&quot;lvweiyaun&quot;]</span>
        <span class="hljs-comment">// child1.friends =  [&quot;a&quot;, &quot;b&quot;]</span>
        <span class="hljs-comment">// p.name =  [&quot;lvweiyaun&quot;]</span>
        <span class="hljs-comment">// child1.name =  [&quot;lvweiyaun&quot;]</span>
        <span class="hljs-comment">// child1.age =  20</span>
        <span class="hljs-comment">// false</span>
</div></code></pre>
<h3 id="37-new">3.7 new</h3>
<h4 id="1-要点-1">1) 要点</h4>
<blockquote>
<ul>
<li>创建一个空对象</li>
<li>函数的作用域指向该对象</li>
<li>对象获取函数的属性和方法</li>
<li>返回新的对象(需要注意的是，假如函数返回的是一个对象，那么最终返回的不是之前创建的空对象，而是函数的返回值)</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">// 方法一</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myNew</span>(<span class="hljs-params">func, ...res</span>) </span>{
            <span class="hljs-keyword">const</span> obj = {};
            obj.__proto__ = func.prototype;
            <span class="hljs-keyword">const</span> result = func.call(obj, ...res);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&#x27;object&#x27;</span> ? result : obj;
        }

        <span class="hljs-comment">// 方法二</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myNew</span>(<span class="hljs-params">func, ...res</span>) </span>{
            <span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Object</span>.create(func.prototype);
            <span class="hljs-keyword">const</span> result = func.call(obj, ...res);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&#x27;object&#x27;</span> ? result : obj;
        }

        <span class="hljs-comment">// 方法三</span>
        <span class="hljs-built_in">Function</span>.prototype.myNew = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">let</span> obj = {};
            obj.__proto__ = <span class="hljs-built_in">this</span>.prototype;
            <span class="hljs-keyword">let</span> argu = [].slice.call(<span class="hljs-built_in">arguments</span>);
            <span class="hljs-built_in">this</span>.call(obj, ...argu);
            <span class="hljs-keyword">return</span> obj;
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params">num1, num2</span>) </span>{
            <span class="hljs-built_in">this</span>.num1 = num1;
            <span class="hljs-built_in">this</span>.num2 = num2;
        }
        a.prototype.tell = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.num1 + <span class="hljs-built_in">this</span>.num2);
        }

        <span class="hljs-keyword">let</span> b = a.myNew(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);
        b.tell(); <span class="hljs-comment">// 3</span>

        <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> a(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);
</div></code></pre>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p><img src="https://github.com/hblvsjtu/FET/blob/master/picture/%E5%9B%BE3-1%20new%E5%8E%9F%E7%90%86.png?raw=true" alt="图3-1 new原理"></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h3 id="38-objectcreate">3.8 Object.create()</h3>
<h4 id="1-参数">1) 参数</h4>
<blockquote>
<ul>
<li>第一个参数是原型对象</li>
<li>第二个参数是属性特性：value, writable, enumberable, congigurable</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-built_in">Object</span>.prototype.myCreate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proto, properties</span>) </span>{
            <span class="hljs-keyword">let</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{};
            f.prototype = proto;
            <span class="hljs-keyword">let</span> o = <span class="hljs-keyword">new</span> f();
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> properties === <span class="hljs-string">&#x27;object&#x27;</span>) {
                <span class="hljs-built_in">Object</span>.defineProperties(o, properties);
            }
            <span class="hljs-keyword">return</span> o;
        }
</div></code></pre>
<h3 id="39-objectkeysobjectvaluesobjectentries">3.9 Object.keys/Object.values/Object.entries</h3>
<h4 id="1-objectkeys">1) Object.keys</h4>
<blockquote>
<ul>
<li>返回对象的每个可枚举的自身属性键名组成的数组</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-built_in">Object</span>.prototype.myKeys = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>) </span>{
            <span class="hljs-keyword">let</span> arr = []
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> o) {
                <span class="hljs-keyword">if</span>(o.hasOwnProperty(key)) arr.push(key);
            }
            <span class="hljs-keyword">return</span> arr;
        }
</div></code></pre>
<h4 id="2-objectvalues">2) Object.values</h4>
<blockquote>
<ul>
<li>返回对象的每个可枚举的自身属性键值组成的数组</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-built_in">Object</span>.prototype.myValues = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>) </span>{
            <span class="hljs-keyword">let</span> arr = []
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> o) {
                <span class="hljs-keyword">if</span>(o.hasOwnProperty(key)) arr.push(o[key]);
            }
            <span class="hljs-keyword">return</span> arr;
        }
</div></code></pre>
<h4 id="2-objectentrie">2) Object.entrie</h4>
<blockquote>
<ul>
<li>返回对象的每个可枚举的自身属性键名和键值组成的数组</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-built_in">Object</span>.prototype.myEntries = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>) </span>{
            <span class="hljs-keyword">let</span> arr = []
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> o) {
                <span class="hljs-keyword">if</span>(o.hasOwnProperty(key)) arr.push([key, o[key]]);
            }
            <span class="hljs-keyword">return</span> arr;
        }
</div></code></pre>
<h3 id="310-settimeout-与-setinterval">3.10 setTimeout 与 setInterval</h3>
<h4 id="1-最短间隔时间">1) 最短间隔时间</h4>
<blockquote>
<ul>
<li>如果回调时间大于间隔时间，浏览器才会执行，这也导致了真正的间隔时间比原来的大一点</li>
<li>这个最短间隔时间该怎么测呢？可以利用在定时器内再嵌一个定时器</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-keyword">let</span> timeList = [];
        <span class="hljs-keyword">let</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">total, delay</span>) </span>{
            <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">let</span> c = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">let</span> id = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                c++;
                timeList.push(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>());
                <span class="hljs-keyword">if</span>(c &gt; total) {
                    <span class="hljs-built_in">clearTimeout</span>(id);
                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; total - <span class="hljs-number">1</span>; i++) {
                sum += timeList[i+<span class="hljs-number">1</span>] - timeList[i];
                    }
                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;the shortest delayTime is &#x27;</span>, sum/(total - <span class="hljs-number">1</span>))
                }
                <span class="hljs-keyword">else</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-built_in">arguments</span>.callee, delay);
            }, delay);
        }
        f(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// the shortest delayTime is 4.878787878787879 in chrome</span>
        f(<span class="hljs-number">1000</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// the shortest delayTime is  83.83883883883884 in chrome</span>
</div></code></pre>
<h3 id="311-跨域">3.11 跨域</h3>
<h4 id="1-通过documentdomain跨域">1) 通过document.domain跨域</h4>
<blockquote>
<ul>
<li>在相同的域名下建立文件</li>
</ul>
</blockquote>
<h4 id="2-通过locationhash跨域">2) 通过location.hash跨域</h4>
<blockquote>
<ul>
<li>但是如果内嵌的页面不同源的话是无法拿到iframe的document的</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-keyword">let</span> src = <span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span>;
        <span class="hljs-keyword">let</span> msg = <span class="hljs-string">&#x27;helloB&#x27;</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createIframe</span>(<span class="hljs-params">src</span>) </span>{    
            <span class="hljs-keyword">let</span> frag = <span class="hljs-built_in">document</span>.createDocumentFragment();
            <span class="hljs-keyword">let</span> ifm = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;iframe&#x27;</span>);
            ifm.src = src;
            ifm.style.display = <span class="hljs-string">&#x27;none&#x27;</span>;
            frag.appendChild(ifm);
            <span class="hljs-built_in">document</span>.body.appendChild(frag);
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkHash</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> location.hash ? location.hash.slice(<span class="hljs-number">1</span>) : <span class="hljs-string">&#x27;&#x27;</span>;
        }
        <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;hashchange&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hash has been changed, now hash is&#x27;</span>, checkHash());
        }, <span class="hljs-literal">false</span>);

        createIframe(src + <span class="hljs-string">&#x27;#&#x27;</span> + msg);

        <span class="hljs-keyword">let</span> i = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;iframe&#x27;</span>)[ <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;iframe&#x27;</span>).length - <span class="hljs-number">1</span>];
        <span class="hljs-keyword">let</span> ifmScript = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);
        ifmScript.innerHTML = <span class="hljs-string">&quot;&quot;</span>
            +  <span class="hljs-string">&quot;let hash = location.hash ? location.hash.slice(1) : &#x27;&#x27;;\n&quot;</span>
            +  <span class="hljs-string">&quot;let message = hash + &#x27;helloA&#x27;;\n&quot;</span>
            +  <span class="hljs-string">&quot;try {\n&quot;</span>
            +  <span class="hljs-string">&quot;  parent.location.hash = message;\n&quot;</span>
            +  <span class="hljs-string">&quot;  console.log(&#x27;OK, i am done, message = &#x27;, message);\n&quot;</span>
            +  <span class="hljs-string">&quot;} catch (e) {\n&quot;</span>
            +  <span class="hljs-string">&quot;  // ie、chrome的安全机制无法修改parent.location.hash，\n&quot;</span>
            +  <span class="hljs-string">&quot;  // 所以要利用一个中间的cnblogs域下的代理iframe\n&quot;</span>
            +  <span class="hljs-string">&quot;  var ifrproxy = document.createElement(&#x27;iframe&#x27;);\n&quot;</span>
            +  <span class="hljs-string">&quot;  ifrproxy.style.display = &#x27;none&#x27;;\n&quot;</span>
            +  <span class="hljs-string">&quot;  ifrproxy.src = &#x27;http://ecma.bdimg.com/adtest/limukai/demo/test/cscript/cs3.html#&#x27; + message;  \n&quot;</span>
            +  <span class="hljs-string">&quot;  // 注意该文件在a.com域下\n&quot;</span>
            +  <span class="hljs-string">&quot;  document.body.appendChild(ifrproxy);\n&quot;</span>
            +  <span class="hljs-string">&quot;  let i = document.getElementsByTagName(&#x27;iframe&#x27;)[ document.getElementsByTagName(&#x27;iframe&#x27;).length - 1];\n&quot;</span>
            +  <span class="hljs-string">&quot;  let ifmScript = document.createElement(&#x27;script&#x27;);\n&quot;</span>
            +  <span class="hljs-string">&quot;  ifmScript.innerHTML = &#x27;parent.parent.location.hash = self.location.hash.substring(1);&#x27;\n&quot;</span>
            +  <span class="hljs-string">&quot;  ifrproxy.appendChild(ifmScript);\n&quot;</span>
            + <span class="hljs-string">&quot;}&quot;</span>
        i.contentWindow.document.body.appendChild(ifmScript);
</div></code></pre>
<h4 id="3-通过postmessage">3) 通过postMessage</h4>
<blockquote>
<ul>
<li>好像也做不了</li>
<li>需要判断源origin，否则容易收到XXR攻击</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-keyword">let</span> msgHandler = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;event.data&#x27;</span>, event.data);
        }
        <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;message&#x27;</span>, msgHandler, <span class="hljs-literal">false</span>);

        <span class="hljs-keyword">let</span> src = <span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span>;
        <span class="hljs-keyword">let</span> msg = <span class="hljs-string">&#x27;helloB&#x27;</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createIframe</span>(<span class="hljs-params">src</span>) </span>{    
            <span class="hljs-keyword">let</span> frag = <span class="hljs-built_in">document</span>.createDocumentFragment();
            <span class="hljs-keyword">let</span> ifm = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;iframe&#x27;</span>);
            ifm.src = src;
            ifm.style.display = <span class="hljs-string">&#x27;none&#x27;</span>;
            frag.appendChild(ifm);
            <span class="hljs-built_in">document</span>.body.appendChild(frag);
        }
        createIframe(src + <span class="hljs-string">&#x27;#&#x27;</span> + msg);

        <span class="hljs-keyword">let</span> i = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;iframe&#x27;</span>)[ <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;iframe&#x27;</span>).length - <span class="hljs-number">1</span>];
        <span class="hljs-keyword">let</span> iframe = i.contentWindow;
        iframe.postMessage(<span class="hljs-string">&#x27;hello world&#x27;</span>, <span class="hljs-string">&#x27;https://segmentfault.com/a/1190000012264815&#x27;</span>);
</div></code></pre>
<h4 id="4-jsonp">4) Jsonp</h4>
<blockquote>
<ul>
<li>只支持GET，不支持POST请求</li>
<li>它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</li>
<li>支持老版本的浏览器</li>
</ul>
</blockquote>
<pre><code class="language-html"><div>            // 自己的页面
            <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exec</span>(<span class="hljs-params">data</span>) </span>{
            <span class="hljs-built_in">console</span>.log(data);
        }
            </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://www.baidu.com?callback=exec&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

            // 后端
        1，判断callback的名称；
        2，处理数据data
        3，返回js文件里面写着： exec(data);
</div></code></pre>
<h4 id="5-access-control-allow-origin">5) Access-Control-Allow-Origin</h4>
<blockquote>
<ul>
<li>存在兼容性的问题，不兼容老版本的浏览器</li>
<li>服务器设置</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">//指定允许其他域名访问</span>
        <span class="hljs-string">&#x27;Access-Control-Allow-Origin:http://172.20.0.206&#x27;</span><span class="hljs-comment">//一般用法（*，指定域，动态设置，但不允许携带认证头和cookies</span>
        <span class="hljs-comment">//是否允许后续请求携带认证信息（cookies）,该值只能是true,否则不返回</span>
        <span class="hljs-string">&#x27;Access-Control-Allow-Credentials:true&#x27;</span>
        <span class="hljs-comment">//预检结果缓存时间</span>
        <span class="hljs-string">&#x27;Access-Control-Max-Age: 1800&#x27;</span>
        <span class="hljs-comment">//允许的请求类型</span>
        <span class="hljs-string">&#x27;Access-Control-Allow-Methods:GET,POST,PUT,POST&#x27;</span>
        <span class="hljs-comment">//允许的请求头字段</span>
        <span class="hljs-string">&#x27;Access-Control-Allow-Headers:x-requested-with,content-type&#x27;</span>
</div></code></pre>
<h3 id="312-函数柯里化">3.12 函数柯里化</h3>
<h4 id="1-定义">1) 定义</h4>
<blockquote>
<ul>
<li>一个函数接受一些参数后返回一个新的函数，这个新的函数继续接收剩余的参数</li>
<li>比如：</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">// 原函数</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">origin</span>(<span class="hljs-params">a, b, c</span>) </span>{

        }

        <span class="hljs-comment">// 柯里化</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">a</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">b, c</span>) </span>{

            }
        }
</div></code></pre>
<h4 id="2-两段不定参数版本">2) 两段不定参数版本</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
         * 
         * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
         * <span class="hljs-doctag">@date    </span>2019-08-01
         * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">let</span> args1 = [].slice.call(<span class="hljs-built_in">arguments</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">let</span> args2 = [].slice.call(<span class="hljs-built_in">arguments</span>);
                argus = args1.concat(args2);
                <span class="hljs-built_in">console</span>.log(argus);
            }
        }
        curry(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>); <span class="hljs-comment">//[1, 2]</span>
        curry(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>); <span class="hljs-comment">//  [1, 2, 2, 3, 4]</span>
</div></code></pre>
<h4 id="3-不定段不定参数版本">3) 不定段不定参数版本</h4>
<blockquote>
<ul>
<li>无限累加器</li>
<li>points</li>
</ul>
<blockquote>
<ul>
<li>改写函数的toSting()和valueOf()方法</li>
<li>返回的函数作为参数收集器</li>
<li>真正做处理方法是toSting()和valueOf()方法</li>
</ul>
</blockquote>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
         * 
         * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
         * <span class="hljs-doctag">@date    </span>2019-08-01
         * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params"></span>) </span>{

            <span class="hljs-keyword">let</span> args = [].slice.call(<span class="hljs-built_in">arguments</span>);

            <span class="hljs-keyword">let</span> _curry = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ 
                <span class="hljs-keyword">let</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    args.push(...arguments) <span class="hljs-comment">// 为了搜集参数</span>
                    <span class="hljs-keyword">return</span> add;
                }

                add.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// 输出结果</span>
                    <span class="hljs-keyword">return</span> args.reduce(<span class="hljs-function">(<span class="hljs-params">total, item</span>) =&gt;</span> {
                <span class="hljs-keyword">return</span> total + item;
                    })
                }
                <span class="hljs-keyword">return</span> add;
            }

            <span class="hljs-keyword">return</span> _curry(...args);
        }
</div></code></pre>
<h3 id="313-高阶函数">3.13 高阶函数</h3>
<h4 id="1-定义-1">1) 定义</h4>
<blockquote>
<ul>
<li>接受一个或多个函数作为输入</li>
<li>输出一个函数</li>
</ul>
</blockquote>
<h4 id="2-实现一个map函数">2) 实现一个map函数</h4>
<blockquote>
<ul>
<li>挂靠在Array数组原型上</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
         * 
         * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
         * <span class="hljs-doctag">@date    </span>2019-08-01
         * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
         */</span>
        <span class="hljs-built_in">Array</span>.prototype.myMap = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">func</span>) </span>{
            <span class="hljs-keyword">let</span> l = <span class="hljs-built_in">this</span>.length;
            <span class="hljs-keyword">let</span> temp = [];
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; l; i++) {
                temp[i] = func(<span class="hljs-built_in">this</span>[i], i, <span class="hljs-built_in">this</span>);
            }
            <span class="hljs-keyword">return</span> temp;
        }
</div></code></pre>
<h4 id="3-实现一个foreach函数">3) 实现一个forEach函数</h4>
<blockquote>
<ul>
<li>挂靠在Array数组原型上</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
         * 
         * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
         * <span class="hljs-doctag">@date    </span>2019-08-01
         * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
         */</span>
        <span class="hljs-built_in">Array</span>.prototype.myForEach = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">func</span>) </span>{
            <span class="hljs-keyword">let</span> l = <span class="hljs-built_in">this</span>.length;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; l; i++) {
        func(<span class="hljs-built_in">this</span>[i], i, <span class="hljs-built_in">this</span>);
            }
        }
</div></code></pre>
<h4 id="4-实现一个reduce函数">4) 实现一个reduce函数</h4>
<blockquote>
<ul>
<li>挂靠在Array数组原型上</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
         * 
         * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
         * <span class="hljs-doctag">@date    </span>2019-08-01
         * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
         */</span>
        <span class="hljs-built_in">Array</span>.prototype.myReduce = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">func, init</span>) </span>{
            <span class="hljs-keyword">let</span> result = init;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) {
        result = func(result, <span class="hljs-built_in">this</span>[i], i);
            }
            <span class="hljs-keyword">return</span> result;
        }
</div></code></pre>
<h4 id="5-实现一个filter函数">5) 实现一个filter函数</h4>
<blockquote>
<ul>
<li>挂靠在Array数组原型上</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
         * 
         * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
         * <span class="hljs-doctag">@date    </span>2019-08-01
         * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
         */</span>
        <span class="hljs-built_in">Array</span>.prototype.myFilter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">func</span>) </span>{
            <span class="hljs-keyword">let</span> l = <span class="hljs-built_in">this</span>.length;
            <span class="hljs-keyword">let</span> arr = [];
            <span class="hljs-keyword">while</span>(l--) <span class="hljs-keyword">if</span>(func(<span class="hljs-built_in">this</span>[l])) arr.unshift(<span class="hljs-built_in">this</span>[l]);
            <span class="hljs-keyword">return</span> arr;
        }
</div></code></pre>
<h3 id="314-迭代器">3.14 迭代器</h3>
<h4 id="1-定义-2">1) 定义</h4>
<pre><code class="language-js"><div>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">iterator</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">let</span> me = <span class="hljs-built_in">this</span>;
            <span class="hljs-keyword">return</span> {
        next() {
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">value</span>: me[i],
                <span class="hljs-attr">done</span>: i++ &gt;= me.length
            }
        }
            }
        }
        a = {
            <span class="hljs-number">0</span>: <span class="hljs-number">0</span>, <span class="hljs-number">1</span>: <span class="hljs-number">1</span>, <span class="hljs-number">2</span>: <span class="hljs-number">2</span>,
            <span class="hljs-attr">length</span>: <span class="hljs-number">3</span>,
            [<span class="hljs-built_in">Symbol</span>.iterator]: iterator
        };

        <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">of</span> a) {
            <span class="hljs-built_in">console</span>.log(i);
        }
        <span class="hljs-comment">// 0 1 2</span>
</div></code></pre>
<h3 id="315-instanceof">3.15 instanceof</h3>
<h4 id="1-定义-3">1) 定义</h4>
<pre><code class="language-js"><div>        <span class="hljs-comment">// 递归版本</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myInstanceof</span>(<span class="hljs-params">left, right</span>) </span>{
            <span class="hljs-keyword">return</span> !left
        ? <span class="hljs-literal">false</span>
        : left.__proto__ === right.prototype
            ? <span class="hljs-literal">true</span>
            : myInstanceof(left.__proto__, right);
        }

        <span class="hljs-comment">// 循环版本</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myInstanceof</span>(<span class="hljs-params">left, right</span>) </span>{
            <span class="hljs-keyword">while</span>(left &amp;&amp; left.__proto__ !== right.prototype) {
        left = left.__proto__;
            }
            <span class="hljs-keyword">return</span> !!left;
        }
</div></code></pre>
<hr>
<h2 id="四正则表达式">四、正则表达式</h2>
<h3 id="41-断言">4.1 断言</h3>
<h4 id="1-定义-4">1) 定义</h4>
<blockquote>
<ul>
<li>断言前面或者后面有规定的字符串，但断言的字符串并不计入输出</li>
</ul>
</blockquote>
<h4 id="2-类型">2) 类型</h4>
<blockquote>
<ul>
<li>向前断言 (?&lt;=) (?&lt;!)</li>
<li>向后断言 (?=) (?!)</li>
</ul>
</blockquote>
<h3 id="42-反向引用">4.2 反向引用</h3>
<h4 id="1-定义-5">1) 定义</h4>
<blockquote>
<ul>
<li>\数字 表示前面匹配到的第n个分组,改分组必须与前面的分组字面上一模一样</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-string">&#x27;168.132.132.132&#x27;</span>.match(<span class="hljs-regexp">/(?:\d{1,3})(\.\d{1,3})\1{2}/</span>);
        <span class="hljs-comment">// [&quot;168.132.132.132&quot;, &quot;.132&quot;, index: 0, input: &quot;168.132.132.132&quot;, groups: undefined]</span>
</div></code></pre>
<h4 id="2-要点">2) 要点</h4>
<blockquote>
<ul>
<li>非获取匹配分组 (?:)，用来忽视某个分组的</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-string">&#x27;168.131.31.1&#x27;</span>.match(<span class="hljs-regexp">/(?:\d{1,3})(\d{1,3}\.)\1{2}/</span>)
</div></code></pre>
<h3 id="43-非贪婪">4.3 非贪婪</h3>
<h4 id="1-定义-6">1) 定义</h4>
<blockquote>
<ul>
<li>用在{1，2}，+,*等后面，匹配最小的那个数量</li>
</ul>
</blockquote>
<h3 id="44-电话号码身份证网址邮箱">4.4 电话号码/身份证/网址/邮箱</h3>
<h4 id="1-qq号码">1) QQ号码</h4>
<blockquote>
<ul>
<li>对QQ号码进行校验要求5~11位,不能以0开头,只能是数字</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        /^[<span class="hljs-number">1</span><span class="hljs-number">-9</span>]\d{<span class="hljs-number">4</span>,<span class="hljs-number">10</span>}$/.test(<span class="hljs-string">&#x27;2606138901&#x27;</span>); <span class="hljs-comment">// true</span>
        <span class="hljs-regexp">/^[1-9]\d{4,10}$/</span>.test(<span class="hljs-string">&#x27;0606138901&#x27;</span>); <span class="hljs-comment">// false</span>
</div></code></pre>
<h4 id="2-电话号码">2) 电话号码</h4>
<blockquote>
<ul>
<li>纯数字第一位必须是1开头第二位必须是3、4、5、7、8,第三位~第十一只要是数字即可</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        /^<span class="hljs-number">1</span>[<span class="hljs-number">34578</span>]\d{<span class="hljs-number">9</span>}$/.test(<span class="hljs-string">&#x27;18028543872&#x27;</span>); <span class="hljs-comment">// true</span>
        <span class="hljs-regexp">/^1[34578]\d{9}$/</span>.test(<span class="hljs-string">&#x27;12028543872&#x27;</span>); <span class="hljs-comment">// false</span>
</div></code></pre>
<h4 id="3-身份证">3) 身份证</h4>
<blockquote>
<ul>
<li>身份证号码为15位或者18位，15位时全为数字，18位前17位为数字，最后一位是校验位，可能为数字或者X或者x</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        /(^\d{<span class="hljs-number">15</span>}$)|(^\d{<span class="hljs-number">17</span>}[\dxX]$)/.test(<span class="hljs-string">&#x27;440782199309241618&#x27;</span>); <span class="hljs-comment">// true</span>
        <span class="hljs-regexp">/(^\d{15}$)|(^\d{17}[\dxX]$)/</span>.test(<span class="hljs-string">&#x27;44078219930924161X&#x27;</span>); <span class="hljs-comment">// true</span>
        <span class="hljs-regexp">/(^\d{15}$)|(^\d{17}[\dxX]$)/</span>.test(<span class="hljs-string">&#x27;44078219930924161s&#x27;</span>); <span class="hljs-comment">// false</span>
</div></code></pre>
<h4 id="3-网址">3) 网址</h4>
<blockquote>
<ul>
<li>DNS规定，域名中的标号都由英文字母和数字组成，每一个标号不超过63个字符，也不区分大小写字母。标号中除连字符（-）外不能使用其他的标点符号。级别最低的域名写在最左边，而级别最高的域名写在最右边。由多个标号组成的完整域名总共不超过255个字符。</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        /^[hH][tT]{<span class="hljs-number">2</span>}[pP][sS]?:\/\/(www\.)?([\w\d-~]{<span class="hljs-number">1</span>,<span class="hljs-number">63</span>}\.)+([\w\d-~\/])+$/.test(<span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span>); <span class="hljs-comment">//true</span>
</div></code></pre>
<h4 id="4-邮箱">4) 邮箱</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        /^[a-zA-Z0<span class="hljs-number">-9</span>]+@[a-zA-Z0<span class="hljs-number">-9</span>]{<span class="hljs-number">1</span>,<span class="hljs-number">5</span>}\.[a-zA-Z0<span class="hljs-number">-9</span>]{<span class="hljs-number">1</span>,<span class="hljs-number">5</span>}$/.test(<span class="hljs-string">&#x27;supersteelsoul@163.com&#x27;</span>); <span class="hljs-comment">// true</span>
</div></code></pre>
<hr>
<h2 id="五js和html效果篇">五、js和html效果篇</h2>
<h3 id="51-获取元素样式位置尺寸">5.1 获取元素样式/位置/尺寸</h3>
<h4 id="1-样式">1) 样式</h4>
<blockquote>
<ul>
<li>element.getAttribute()方法 只能获取内联样式的内容</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-keyword">var</span> btn=element.getAttribute(<span class="hljs-string">&#x27;style&#x27;</span>);
</div></code></pre>
<blockquote>
<ul>
<li>document.styleSheets 获取内嵌样式表或外联样式表，返回值是一个数组</li>
</ul>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-keyword">var</span> styleSheetList = <span class="hljs-built_in">document</span>.styleSheets;
        <span class="hljs-keyword">var</span> styleSheet = styleSheetList[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">var</span> cssRuleList = styleSheet.rules;
        <span class="hljs-keyword">var</span> cssStyleRule = cssRuleList[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">var</span> styleDecl = cssStyleRule.style;
        <span class="hljs-built_in">console</span>.log(styleDecl.width);
</div></code></pre>
<blockquote>
<ul>
<li>class属性的操作</li>
</ul>
<blockquote>
<ul>
<li>className</li>
<li>classList 兼容性问题。如果该类名不存在则会在元素中添加类名，并返回 true。 第二个是可选参数，是个布尔值用于设置元素是否强制添加或移除类，不管该类名是否存在.注意： Internet Explorer 或 Opera 12 及其更早版本不支持第二个参数。</li>
</ul>
</blockquote>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">//元素名.className 需要操作字符串,每个类中间用空格隔开</span>
        <span class="hljs-keyword">var</span> className = ele.className;
        className.replace(<span class="hljs-string">&#x27;classNameA&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-regexp">/\s+/g</span>, <span class="hljs-string">&#x27; &#x27;</span>);
        className.concat(<span class="hljs-string">&#x27; classNameB&#x27;</span>).replace(<span class="hljs-regexp">/\s+/g</span>, <span class="hljs-string">&#x27; &#x27;</span>);
        
        <span class="hljs-comment">//classList属性(浏览器兼容问题)：获取多个类选择器叠加的用法</span>
        <span class="hljs-comment">//元素名.classList</span>
        <span class="hljs-keyword">var</span> classList = ele.classList;
        classList.add(<span class="hljs-string">&#x27;className&#x27;</span>);
        classList.remove(<span class="hljs-string">&#x27;className&#x27;</span>);
        classList.contains(<span class="hljs-class"><span class="hljs-keyword">class</span>)
        <span class="hljs-title">classList</span>.<span class="hljs-title">toggle</span>(<span class="hljs-title">class</span>, <span class="hljs-title">true</span>|<span class="hljs-title">false</span>) // 第一个参数为要在元素中移除的类名，并返回 <span class="hljs-title">false</span>。
</span></div></code></pre>
<blockquote>
<blockquote>
<ul>
<li>自定义类解决兼容性问题，可以兼容IE7</li>
</ul>
</blockquote>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
         * 
         * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
         * <span class="hljs-doctag">@date    </span>2019-08-01
         * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
         */</span>
        <span class="hljs-built_in">Object</span>.prototype.myClassList = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> self = <span class="hljs-built_in">this</span>;
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">list</span>: self.className,
                <span class="hljs-attr">add</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">className</span>) </span>{
                    self.className = self.className.concat(<span class="hljs-string">&#x27; &#x27;</span> + className);
                },
                <span class="hljs-attr">remove</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">className</span>) </span>{
                    self.className = self.className.replace(className, <span class="hljs-string">&#x27;&#x27;</span>);
                },
                <span class="hljs-attr">contains</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">className</span>) </span>{
                    <span class="hljs-keyword">return</span> self.className.split(<span class="hljs-regexp">/\s+/g</span>).indexOf(className) &gt; <span class="hljs-number">-1</span>;
                },
                <span class="hljs-attr">toggle</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">className</span>) </span>{
                    <span class="hljs-keyword">if</span>(self.myClassList().contains(className)) {
                self.myClassList().remove(className);
                    }
                    <span class="hljs-keyword">else</span> {
                self.myClassList().add(className);
                    }
                }
            }
        }

        <span class="hljs-comment">//</span>
        &gt; div.listClass().list;
        &lt; <span class="hljs-string">&quot;s_tab&quot;</span>
        &gt; div.listClass().add(<span class="hljs-string">&#x27;asd&#x27;</span>);
        &lt; <span class="hljs-literal">undefined</span>
        &gt; div.listClass().list;
        &lt; <span class="hljs-string">&quot;s_tab asd&quot;</span>
        &gt; div.listClass().remove(<span class="hljs-string">&#x27;asd&#x27;</span>);
        &lt; <span class="hljs-literal">undefined</span>
        &gt; div.listClass().list;
        &lt; <span class="hljs-string">&quot;s_tab &quot;</span>
        &gt; div.listClass().contains(<span class="hljs-string">&#x27;asd&#x27;</span>);
        &lt; <span class="hljs-literal">false</span>
        &gt; div.listClass().contains(<span class="hljs-string">&#x27;s_tab&#x27;</span>);
        &lt; <span class="hljs-literal">true</span>
        &gt; div.listClass().contains(<span class="hljs-string">&#x27;s_ta&#x27;</span>);
        &lt; <span class="hljs-literal">false</span>
        &gt; div.listClass().toggle(<span class="hljs-string">&#x27;s_ta&#x27;</span>);
        &lt; <span class="hljs-literal">undefined</span>
        &gt; div.listClass().contains(<span class="hljs-string">&#x27;s_ta&#x27;</span>);
        &lt; <span class="hljs-literal">true</span>
        &gt; div.listClass().list;
        &lt; <span class="hljs-string">&quot;s_tab  s_ta&quot;</span> 
</div></code></pre>
<blockquote>
<ul>
<li>获取实时计算的样式 getComputedStyle</li>
</ul>
<blockquote>
<ul>
<li>只读的，不能写。</li>
<li>获取的是最终应用在元素上的所有CSS属性对象</li>
<li>currentStyle不能读取伪类，但是getComputedStyle可以</li>
<li>currentStyle是IE自娱自乐的玩意</li>
<li>在访问例如background-color类似格式的css属性时</li>
</ul>
</blockquote>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-built_in">window</span>.getComputedStyle(ele,<span class="hljs-literal">null</span>).background-color <span class="hljs-comment">//就不可以了，需要使用</span>
        <span class="hljs-built_in">window</span>.getComputedStyle(ele,<span class="hljs-literal">null</span>).backgroundColor <span class="hljs-comment">//可以</span>
        <span class="hljs-built_in">window</span>.getComputedStyle(ele,<span class="hljs-literal">null</span>).getPropertyValue(“background-color”) <span class="hljs-comment">// 可以</span>
        
        <span class="hljs-keyword">var</span> style = <span class="hljs-built_in">window</span>.getComputedStyle(<span class="hljs-string">&quot;元素&quot;</span>, <span class="hljs-string">&quot;伪类&quot;</span>);
        ele.currentStyle[attr]

        <span class="hljs-comment">// 兼容性写法 如果遇到text的时候会报错，这里return null可以吃掉报错</span>
        <span class="hljs-comment">/**
          * 
          * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
          * <span class="hljs-doctag">@date    </span>2019-08-01
          * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
          */</span>

        <span class="hljs-built_in">Object</span>.prototype.getMyStyle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attr, pseudoElt</span>) </span>{
            <span class="hljs-keyword">let</span> style = <span class="hljs-string">&#x27;&#x27;</span>;
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.currentStyle) {
                    style = <span class="hljs-built_in">this</span>.currentStyle[attr];
                }
                <span class="hljs-keyword">else</span> {
                    style = <span class="hljs-built_in">window</span>.getComputedStyle(<span class="hljs-built_in">this</span>, pseudoElt)[attr];
                }
            }
            <span class="hljs-keyword">catch</span> (e) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            }
            <span class="hljs-keyword">return</span> style;
        }

        <span class="hljs-comment">// ie7可能会返回auto值而不是实际的值</span>
</div></code></pre>
<h4 id="2-位置">2) 位置</h4>
<blockquote>
<ul>
<li>元素的位置</li>
</ul>
<blockquote>
<ul>
<li><code>getClientRects</code> 返回一个数组，但是该数组只有一个元素，而且是一个对象元素，获取的是距离目标元素最近的父元素的距离</li>
<li><code>offsetTop</code>,<code>offsetLeft</code>和<code>offsetParent</code>，而非视窗距离</li>
<li><code>getBoundingClientRect</code>用于获取元素相对与浏览器视口的位置，它是一个对象</li>
<li>想要获取元素边内界边缘相对于文档顶部的距离，需要用到<code>getBoundingClientRect</code>或者递归<code>offsetTop</code>和<code>offsetLeft</code></li>
</ul>
</blockquote>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">// getBoundingClientRect方法</span>
        <span class="hljs-attr">getBoundingClientRect</span>: {
            <span class="hljs-attr">top</span>: <span class="hljs-string">&#x27;元素顶部相对于视口顶部的距离&#x27;</span>,
            <span class="hljs-attr">bottom</span>: <span class="hljs-string">&#x27;元素底部相对于视口顶部的距离&#x27;</span>,
            <span class="hljs-attr">left</span>: <span class="hljs-string">&#x27;元素左边相对于视口左边的距离&#x27;</span>,
            <span class="hljs-attr">right</span>: <span class="hljs-string">&#x27;元素右边相对于视口左边的距离&#x27;</span>,
            <span class="hljs-attr">height</span>: <span class="hljs-string">&#x27;元素高度&#x27;</span>,
            <span class="hljs-attr">width</span>: <span class="hljs-string">&#x27;元素宽度&#x27;</span>
            <span class="hljs-attr">x</span>: <span class="hljs-number">8</span>,
            <span class="hljs-attr">y</span>: <span class="hljs-number">8</span>,
        }

        <span class="hljs-comment">// 递归法</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDistance</span>(<span class="hljs-params">node</span>) </span>{
            <span class="hljs-keyword">return</span> node.parentNode ? getDistance(node.parentNode) + node.offsetTop : <span class="hljs-number">0</span>;
        }
</div></code></pre>
<blockquote>
<blockquote>
<ul>
<li>兼容性写法 因为IE没有height和width</li>
</ul>
</blockquote>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">// 兼容写法</span>
         <span class="hljs-comment">/**
          * 
          * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
          * <span class="hljs-doctag">@date    </span>2019-08-01
          * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
          */</span>

          <span class="hljs-built_in">Object</span>.prototype.getMyRect = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">isToHtml</span>) </span>{
             <span class="hljs-keyword">var</span> o = <span class="hljs-built_in">this</span>.getBoundingClientRect();
             <span class="hljs-keyword">var</span> self = <span class="hljs-built_in">this</span>;
             <span class="hljs-keyword">var</span> offset = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ele</span>) </span>{
                <span class="hljs-keyword">var</span> parent = ele.offsetParent;
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-attr">top</span>: isToHtml &amp;&amp; parent.offsetParent? ele.offsetTop + offset(parent).top :  ele.offsetTop, 
                    <span class="hljs-attr">left</span>: isToHtml &amp;&amp; parent.offsetParent ? ele.offsetLeft + offset(parent).left :  ele.offsetLeft
                }
             }
             <span class="hljs-keyword">return</span> {
                 <span class="hljs-attr">viewTop</span>: o.top, <span class="hljs-comment">// 获取元素内边距边缘离视窗的距离</span>
                 <span class="hljs-attr">viewBottom</span>: o.bottom, <span class="hljs-comment">// 获取元素内边距边缘离视窗的距离</span>
                 <span class="hljs-attr">viewLeft</span>: o.left, <span class="hljs-comment">// 获取元素内边距边缘离视窗的距离</span>
                 <span class="hljs-attr">viewRight</span>: o.right, <span class="hljs-comment">// 获取元素内边距边缘离视窗的距离</span>
                 <span class="hljs-attr">height</span>: o.height || o.bottom - o.top, <span class="hljs-comment">// 获取元素上下内边缘高度，不包括边距</span>
                 <span class="hljs-attr">width</span>: o.width || o.right - o.left, <span class="hljs-comment">// 获取元素上下内边缘宽度，不包括边距</span>
                    <span class="hljs-attr">offsetTop</span>: offset(self).top, <span class="hljs-comment">//获取元素内边缘距离定位父元素的距离</span>
                    <span class="hljs-attr">offsetLeft</span>: offset(self).left <span class="hljs-comment">//获取元素内边缘距离定位父元素的距离</span>
             }
         }
</div></code></pre>
<blockquote>
<blockquote>
<ul>
<li>一个例子</li>
</ul>
</blockquote>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">// main.html</span>
        &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;contain&quot;</span>&gt;
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;camera&quot;</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cube&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
        &lt;/div&gt;

        <span class="hljs-comment">// main.css</span>
        @charset <span class="hljs-string">&quot;UTF-8&quot;</span>;
        <span class="hljs-comment">/**
         * 
         * @authors ${冰红茶} (${hblvsjtu@163.com})
         * @date    2019-07-31
         * @version $0.0.1$
         */</span>

        .contain {
            <span class="hljs-attr">position</span>: relative;
            top: <span class="hljs-number">100</span>px;
            left: <span class="hljs-number">100</span>px;
            height: <span class="hljs-number">500</span>px;
            width: <span class="hljs-number">500</span>px;
            overflow: scroll;
            background: yellow;
        }

         .camera {
            <span class="hljs-attr">position</span>: absolute;
            top: <span class="hljs-number">400</span>px;
            left: <span class="hljs-number">400</span>px;
            width: <span class="hljs-number">200</span>px;
            height: <span class="hljs-number">200</span>px;
            background: red;
         }
         .camera .cube {
            <span class="hljs-attr">width</span>: <span class="hljs-number">100</span>px;
            height: <span class="hljs-number">100</span>px;
            margin: <span class="hljs-number">50</span>px;
            background: green;
         }

         <span class="hljs-keyword">let</span> contain = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">&#x27;contain&#x27;</span>)[<span class="hljs-number">0</span>];
         <span class="hljs-keyword">let</span> camera = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">&#x27;camera&#x27;</span>)[<span class="hljs-number">0</span>];
         <span class="hljs-keyword">let</span> cube = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">&#x27;cube&#x27;</span>)[<span class="hljs-number">0</span>];
         <span class="hljs-keyword">let</span> camera = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">&#x27;camera&#x27;</span>)[<span class="hljs-number">0</span>];
</div></code></pre>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p><img src="https://github.com/hblvsjtu/FET/blob/master/picture/%E5%9B%BE5-1%20%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AEa.png?raw=true" alt="图5-1 元素位置a">
<img src="https://github.com/hblvsjtu/FET/blob/master/picture/%E5%9B%BE5-1%20%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AEb.png?raw=true" alt="图5-1 元素位置b">
<img src="https://github.com/hblvsjtu/FET/blob/master/picture/%E5%9B%BE5-1%20%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AEc.png?raw=true" alt="图5-1 元素位置c">
<img src="https://github.com/hblvsjtu/FET/blob/master/picture/%E5%9B%BE5-1%20%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AEd.png?raw=true" alt="图5-1 元素位置d"></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<ul>
<li>滚动条滚动的距离</li>
</ul>
<blockquote>
<ul>
<li>所有主流浏览器都支持 pageXOffset 和 pageYOffset 属性。注意： IE 8 及 更早 IE版本不支持该属性,但可以使用&quot;document.body.scrollLeft&quot; 和 &quot;document.body.scrollTop&quot; 属性 。</li>
<li>chrome可以使用document.documentElement.scrollLeft和document.documentElement.scrollTop,或者window.pageXoffset与window.pageYoffset。</li>
<li>不管怎样，document.documentElement.scrollTop和document.body.scrollTop只有一个有效，另外一个为0，我们可以利用这一个特点写兼容性</li>
<li>chrome里面的document.body.scrollHeight和document.body.scrollWidth偏小，而document.documentElement.scrollHeight和document.documentElement.scrollWidth正常，且IE也能用，所以就使用document.documentElement.scrollHeight和document.documentElement.scrollWidth吧</li>
</ul>
</blockquote>
<ul>
<li>视窗高度和宽度</li>
</ul>
<blockquote>
<ul>
<li>视窗高度window.innerHeight</li>
<li>视窗宽度window.innerWidth</li>
</ul>
</blockquote>
<ul>
<li>元素内边距边缘距离文档顶部的距离</li>
</ul>
<blockquote>
<ul>
<li>offsetTop 和 offsetLeft 都是相对于其内边距边界的。</li>
<li>HTMLElement.offsetParent 是一个只读属性，返回一个指向最近的定位父元素。如果没有定位的元素，则指向最近的 table 元素或根元素（标准模式下为 html；quirks 模式下为 body）。当元素的 style.display 设置为 &quot;none&quot; 时，offsetParent 返回 null。</li>
</ul>
</blockquote>
</blockquote>
<pre><code class="language-js"><div>        <span class="hljs-comment">/**
         * 
         * <span class="hljs-doctag">@authors </span>${冰红茶} (${hblvsjtu@163.com})
         * <span class="hljs-doctag">@date    </span>2019-08-01
         * <span class="hljs-doctag">@version <span class="hljs-variable">$Id$</span></span>
         */</span>
        <span class="hljs-comment">// 兼容性写法</span>
        <span class="hljs-built_in">window</span>.getWindowSize = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc</span>) </span>{
            <span class="hljs-keyword">let</span> myDocument = doc || <span class="hljs-built_in">document</span>;
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">scrollTop</span>: myDocument.documentElement.scrollTop || myDocument.body.scrollTop,
                <span class="hljs-attr">scrollLeft</span>: myDocument.documentElement.scrollLeft || myDocument.body.scrollLeft,
                <span class="hljs-attr">wholeHeight</span>: myDocument.documentElement.scrollHeight,
                <span class="hljs-attr">wholeWidth</span>: myDocument.documentElement.scrollWidth,
                <span class="hljs-attr">innerHeight</span>: <span class="hljs-built_in">window</span>.innerHeight,
                <span class="hljs-attr">innerWidth</span>: <span class="hljs-built_in">window</span>.innerWidth,
                <span class="hljs-attr">outerHeight</span>: <span class="hljs-built_in">window</span>.outerHeight,
                <span class="hljs-attr">outerWidth</span>: <span class="hljs-built_in">window</span>.outerWidth
            }
        }
</div></code></pre>
<h3 id="52-拖拽">5.2 拖拽</h3>
<h4 id="1-行内元素">1) 行内元素</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<h3 id="53-图片懒加载">5.3 图片懒加载</h3>
<h4 id="1-行内元素-1">1) 行内元素</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<h3 id="54-轮播">5.4 轮播</h3>
<h4 id="1-行内元素-2">1) 行内元素</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<h3 id="55-滑动">5.5 滑动</h3>
<h4 id="1-行内元素-3">1) 行内元素</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<h3 id="56-级联">5.6 级联</h3>
<h4 id="1-行内元素-4">1) 行内元素</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<h3 id="57-图片剪裁">5.7 图片剪裁</h3>
<h4 id="1-行内元素-5">1) 行内元素</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<h3 id="58-图片压缩">5.8 图片压缩</h3>
<h4 id="1-行内元素-6">1) 行内元素</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<h3 id="59-tab">5.9 Tab</h3>
<h4 id="1-行内元素-7">1) 行内元素</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<hr>
<h2 id="六css效果篇">六、CSS效果篇</h2>
<h3 id="61-水平居中">6.1 水平居中</h3>
<h4 id="1-行内元素-8">1) 行内元素</h4>
<blockquote>
<ul>
<li>父元素上text-align: center;</li>
</ul>
</blockquote>
<pre><code class="language-html"><div>        // main.html
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;contain&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;centerText&quot;</span>&gt;</span>我是居中的行内元素<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        // main.css
        @charset &quot;UTF-8&quot;;
        /**
         * 
         * @authors ${冰红茶} (${hblvsjtu@163.com})
         * @date    2019-07-31
         * @version $0.0.1$
         */
         
        .contain {
            text-align: center;
            background: #000;
        }

         .centerText {
            background: #fff;
        }
</div></code></pre>
<h4 id="2-块级元素">2) 块级元素</h4>
<blockquote>
<ul>
<li>定宽居中</li>
</ul>
<blockquote>
<ul>
<li>自身元素上margin: auto; 一定要写width;</li>
</ul>
</blockquote>
</blockquote>
<pre><code class="language-html"><div>        // main.html
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;contain&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;centerBlock&quot;</span>&gt;</span>我是居中的块级元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        // main.css
        @charset &quot;UTF-8&quot;;
        /**
         * 
         * @authors ${冰红茶} (${hblvsjtu@163.com})
         * @date    2019-07-31
         * @version $0.0.1$
         */
         
        .contain {
            background: #000;
        }

        .centerBlock {
            width: 100px;
            margin: auto;
            background: #fff;
        } 
</div></code></pre>
<blockquote>
<ul>
<li>inline-block不定宽居中</li>
</ul>
<blockquote>
<ul>
<li>把块状元素的显示值设置为inline-block</li>
<li>然后使用行内元素的text-align: center;</li>
</ul>
</blockquote>
</blockquote>
<pre><code class="language-html"><div>        // main.html
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;contain&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;centerBlock&quot;</span>&gt;</span>我是居中的块级元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        // main.css
        @charset &quot;UTF-8&quot;;
        /**
         * 
         * @authors ${冰红茶} (${hblvsjtu@163.com})
         * @date    2019-07-31
         * @version $0.0.1$
         */
         
        .contain {
            text-align: center;
            background: #000;
        }

        .centerBlock {
            display: inline-block;
            background: #fff;
        }
</div></code></pre>
<blockquote>
<ul>
<li>绝对定位不定宽居中</li>
</ul>
<blockquote>
<ul>
<li>注意IE8及以下不支持transform，其他的也需要加后缀</li>
</ul>
</blockquote>
</blockquote>
<pre><code class="language-html"><div>        // main.html
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;contain&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;centerBlock&quot;</span>&gt;</span>我是居中的块级元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        // main.css
        @charset &quot;UTF-8&quot;;
        /**
         * 
         * @authors ${冰红茶} (${hblvsjtu@163.com})
         * @date    2019-07-31
         * @version $0.0.1$
         */
         
        .contain {
            position: relative;
            background: #000;
        }

        .centerBlock {
            display: inline-block;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            background: #fff;
        }
</div></code></pre>
<blockquote>
<ul>
<li>table-cell不定宽居中</li>
</ul>
<blockquote>
<ul>
<li>注意table-cell的特性有点像inline-block，需要设置width，而且不接受百分比，只接受数值，table-cell</li>
<li>IE6 IE7无效</li>
</ul>
</blockquote>
</blockquote>
<pre><code class="language-html"><div>        // main.html
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;contain&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;centerBlock&quot;</span>&gt;</span>我是居中的块级元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        // main.css
        @charset &quot;UTF-8&quot;;
        /**
         * 
         * @authors ${冰红茶} (${hblvsjtu@163.com})
         * @date    2019-07-31
         * @version $0.0.1$
         */
         
        .contain {
            display: table-cell;
            width: 400px;
            text-align: center;
            background: #000;
        }

        .centerBlock {
            display: inline-block;
            background: #fff;
        } 
</div></code></pre>
<h3 id="62-垂直居中">6.2 垂直居中</h3>
<h4 id="1-行内元素-9">1) 行内元素</h4>
<blockquote>
<ul>
<li>父元素需要设置行高</li>
<li>自身元素上设置vertical-align</li>
</ul>
</blockquote>
<pre><code class="language-html"><div>        // main.html
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;contain&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;centerText&quot;</span>&gt;</span>我是居中的行内元素<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        // main.css
        @charset &quot;UTF-8&quot;;
        /**
         * 
         * @authors ${冰红茶} (${hblvsjtu@163.com})
         * @date    2019-07-31
         * @version $0.0.1$
         */
         
        .contain {
            line-height: 400px;
            vertical-align: middle;
            background: #000;
        }

         .centerText {
            background: #fff;
        }
</div></code></pre>
<h4 id="2-块级元素-1">2) 块级元素</h4>
<blockquote>
<ul>
<li>line-height不定高居中</li>
</ul>
<blockquote>
<ul>
<li>父元素需要设置行高，高度将被行高顶起，相当于设了高度</li>
<li>子元素设置vertical-align: middle，这是因为子元素被设为inline-block后，其基线将于内部文字的中线重合</li>
<li>由于父元素的行高等于自身高度，而子元素的基线在内部文字的中线上，所以就变成竖直居中了</li>
<li>会存在幽灵空白节点的问题，详细看<a href="#6.5">6.5 消除幽灵空格</a></li>
</ul>
</blockquote>
</blockquote>
<pre><code class="language-html"><div>        // main.html
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;contain&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;centerBlock&quot;</span>&gt;</span>我是居中的块级元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        // main.css
        @charset &quot;UTF-8&quot;;
        /**
         * 
         * @authors ${冰红茶} (${hblvsjtu@163.com})
         * @date    2019-07-31
         * @version $0.0.1$
         */
         
        .contain {
            line-height: 100px;
            background: #000;
        }

        .centerBlock {
            display: inline-block;
            line-height: 1;
            vertical-align: middle; 
            background: #fff;
        }
</div></code></pre>
<blockquote>
<ul>
<li>绝对定位不定高居中</li>
</ul>
<blockquote>
<ul>
<li>注意IE8及以下不支持transform，其他的也需要加后缀</li>
<li>父元素需要设置高度</li>
</ul>
</blockquote>
</blockquote>
<pre><code class="language-html"><div>        // main.html
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;contain&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;centerBlock&quot;</span>&gt;</span>我是居中的块级元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        // main.css
        @charset &quot;UTF-8&quot;;
        /**
         * 
         * @authors ${冰红茶} (${hblvsjtu@163.com})
         * @date    2019-07-31
         * @version $0.0.1$
         */
         
        .contain {
            position: relative;
            height: 100px;
            background: #000;
        }

        .centerBlock {
            display: inline-block;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: #fff;
        }
</div></code></pre>
<blockquote>
<ul>
<li>table-cell不定高居中</li>
</ul>
<blockquote>
<ul>
<li>注意table-cell的特性有点像inline-block</li>
<li>父元素需要设置计算值为table-cell，vertical-align: middle，高度不接受百分比，只接受数值，margin设置无效，响应padding设置</li>
<li>不同于水平居中，子元素不必一定是inline-block，高度会自动适应</li>
<li>IE6 IE7无效</li>
</ul>
</blockquote>
</blockquote>
<pre><code class="language-html"><div>        // main.html
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;contain&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;centerBlock&quot;</span>&gt;</span>我是居中的块级元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        // main.css
        @charset &quot;UTF-8&quot;;
        /**
         * 
         * @authors ${冰红茶} (${hblvsjtu@163.com})
         * @date    2019-07-31
         * @version $0.0.1$
         */
         
        .contain {
            display: table-cell;
            height: 400px;
            vertical-align: middle;
            background: #000;
        }

        .centerBlock {
            background: #fff;
        } 
</div></code></pre>
<h3 id="63-水平垂直居中">6.3 水平垂直居中</h3>
<h4 id="1-绝对定位auto方案">1) 绝对定位auto方案</h4>
<blockquote>
<ul>
<li>需要已知长度和高度</li>
</ul>
</blockquote>
<pre><code class="language-html"><div>        // main.html
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;contain&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;centerBlock&quot;</span>&gt;</span>我是居中的块级元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        // main.css
        @charset &quot;UTF-8&quot;;
        /**
         * 
         * @authors ${冰红茶} (${hblvsjtu@163.com})
         * @date    2019-07-31
         * @version $0.0.1$
         */
         
        .contain {
            position: relative;
            width: 100px;
            height: 100px;
            background: #000;
        }

        .centerBlock {
            display: inline-block;
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            width: 40px;
            height: 40px;
            margin: auto;
            background: #fff;
        }
</div></code></pre>
<h4 id="2-绝对定位translate方案">2) 绝对定位translate方案</h4>
<blockquote>
<ul>
<li>不需要已知长度和高度</li>
</ul>
</blockquote>
<pre><code class="language-html"><div>        // main.html
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;contain&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;centerBlock&quot;</span>&gt;</span>我是居中的块级元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        // main.css
        @charset &quot;UTF-8&quot;;
        /**
         * 
         * @authors ${冰红茶} (${hblvsjtu@163.com})
         * @date    2019-07-31
         * @version $0.0.1$
         */
         
        .contain {
            position: relative;
            width: 100px;
            height: 100px;
            background: #000;
        }

        .centerBlock {
            display: inline-block;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #fff;
        }
</div></code></pre>
<h4 id="3-inline-block方案">3) inline-block方案</h4>
<blockquote>
<ul>
<li>vertical-align and text-align</li>
<li>如果子元素内部有多行文字，且没有设vertical-align: middle;那么竖直方向上第一行会往上跳，居中对齐的是最后一行中间。</li>
<li>会存在幽灵空白节点的问题，详细看<a href="#6.5">6.5 消除幽灵空格</a></li>
</ul>
</blockquote>
<pre><code class="language-html"><div>        // main.html
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;contain&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;centerBlock&quot;</span>&gt;</span>我是居中的块级元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        // main.css
        .contain {
            width: 100px;
            line-height: 100px;
            text-align: center;
            background: #000;
        }

        .centerBlock {
            display: inline-block;
            line-height: 1;
            vertical-align: middle;
            background: #fff;
        }
</div></code></pre>
<h4 id="4-table-cell方案">4) table-cell方案</h4>
<blockquote>
<ul>
<li>不需要理会行高的问题，只用text-align和vertical-align就能保证</li>
<li>自身元素计算值设为inline-block</li>
</ul>
</blockquote>
<pre><code class="language-html"><div>        // main.html
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;contain&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;centerBlock&quot;</span>&gt;</span>我是居中的块级元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        // main.css
        @charset &quot;UTF-8&quot;;
        /**
         * 
         * @authors ${冰红茶} (${hblvsjtu@163.com})
         * @date    2019-07-31
         * @version $0.0.1$
         */
         
        .contain {
            display: table-cell;
            width: 100px;
            height: 100px;
            text-align: center;
            vertical-align: middle;
            background: #000;
        }

        .centerBlock {
            display: inline-block;
            background: #fff;
        }
</div></code></pre>
<h3 id="64-清除浮动">6.4 清除浮动</h3>
<h4 id="1-原因">1) 原因</h4>
<blockquote>
<ul>
<li>对于块级元素，当其高度没有被指定的时候，其高度由内部的存在于文档流中的元素的高度所决定。但是，问题来了，如果内部的某个元素由于浮动或者绝对定位等原因脱离了文档流，但么块级元素的高度可能会发生变化(变小)，严重的可能会引起高度坍塌。</li>
<li><a href="https://segmentfault.com/a/1190000007030144">浮动元素会脱离文档流但不会脱离文本流，因而会造成文本环绕效果，而这也是浮动的本意。</a></li>
<li><a href="https://segmentfault.com/a/1190000007030144">浮动元素的外边距不会合并</a></li>
<li><a href="https://segmentfault.com/a/1190000007030144">浮动非替换元素时必须设定宽度</a></li>
<li><a href="https://segmentfault.com/a/1190000007030144">浮动元素会脱离文档流但不会脱离文本流，因而会造成文本环绕效果，而这也是浮动的本意。</a></li>
<li><a href="https://segmentfault.com/a/1190000007030144">不管是块级元素还是内联元素，一旦浮动就会变成行内块元素（即display: inline-block;）</a></li>
<li><a href="https://segmentfault.com/a/1190000007030144">如果浮动元素应用了负外边距而导致其与相邻元素重叠，分两种情况：</a></li>
</ul>
<blockquote>
<ul>
<li><a href="https://segmentfault.com/a/1190000007030144">行内框与一个浮动元素重叠时，其边框、背景和内容都在该浮动元素之上显示</a></li>
<li><a href="https://segmentfault.com/a/1190000007030144">块框与一个浮动元素重叠时，其边框和背景都在该浮动元素之下显示，而内容在浮动元素之上显示</a></li>
</ul>
</blockquote>
</blockquote>
<h4 id="2-解决办法">2) 解决办法</h4>
<blockquote>
<ul>
<li>BFC block-formatting context 块级格式化上下文</li>
<li>BFC有一个特性：内部元素无论怎么'折腾'，都不会干扰外部的元素。这意味着不会发生margin重叠，也不会发生高度坍塌。</li>
</ul>
<blockquote>
<ul>
<li>html根元素</li>
<li>float的值不为none；</li>
<li>position的值不为relative和static</li>
<li>overflow为auto，scroll，hidden</li>
<li>display的值为table-cell、table-caption和inline-block</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p><img src="https://github.com/hblvsjtu/FET/blob/master/picture/%E5%9B%BE6-1%20%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8.png?raw=true" alt="图6-1 清除浮动"></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<pre><code class="language-html"><div>        // main.html
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;contain&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;floatBlock&quot;</span>&gt;</span>我是正常元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;contain&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;floatBlock&quot;</span>&gt;</span>我是浮动元素造成了坍塌<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;contain&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;floatBlock&quot;</span>&gt;</span>我是浮动元素经过了overflow：hidden修复<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;contain&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;floatBlock&quot;</span>&gt;</span>我是浮动元素经过了父元素inline-block修复<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;contain&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;floatBlock&quot;</span>&gt;</span>我是浮动元素经过了父元素clear:both修复<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;contain&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;floatBlock&quot;</span>&gt;</span>我是浮动元素经过了父元素absolute修复<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        // main.css
        @charset &quot;UTF-8&quot;;
        /**
         * 
         * @authors ${冰红茶} (${hblvsjtu@163.com})
         * @date    2019-07-31
         * @version $0.0.1$
         */
         
        .contain {
            width: 400px;
            background: #000;
        }

        .floatBlock {
            display: inline-block;
            width: 200px;
            margin: 10px;
            height: 50px;
            background: #fff;
        }

        .contain:nth-child(2) .floatBlock,
        .contain:nth-child(3) .floatBlock,
        .contain:nth-child(4) .floatBlock,
        .contain:nth-child(5) .floatBlock,
        .contain:nth-child(6) .floatBlock {
            float: left;
        }

        .contain:nth-child(3){
            overflow: hidden;
        }

        .contain:nth-child(4) {
            display: inline-block;
        }

        .contain:nth-child(5) {
            zoom: 1;
        }
        .contain:nth-child(5)::after {
            content: &#x27;&#x27;;
            display: block;
            height: 0;
            visibility: hidden;
            clear: both;
        }

        .contain:nth-child(6) {
            position: absolute;
        }
</div></code></pre>
<h3 id="65-幽灵空白节点">6.5 幽灵空白节点</h3>
<h4 id="1-w3c规范">1) W3C规范</h4>
<blockquote>
<ul>
<li>line boxes are created as needed to hold inline-level content within an inline formatting context. Line boxes that contain no text, no preserved white space, no inline elements with non-zero margins, padding, or borders, and no other in-flow content (such as images, inline blocks or inline tables), and do not end with a preserved newline must be treated as zero-height line boxes for the purposes of determining the positions of any elements inside of them, and must be treated as not existing for any other purpose.</li>
<li>如果一个line box里没有文字、保留的空格、非0的margin或padding或border的inline元素、或其他in-flow内容（比如图片、inline-block或inline-table元素），且不以保留的换行符结束的话，就会被视作高度为0的line box。但是一旦出现以上任意一种情况，就会出现幽灵空白节点。说白点，行框里只要有in-flow（图片、inline-block或inline-table元素），就会出现幽灵空白节点</li>
<li>在一个行框内，对于一个inline-block，如果内部没有文字，或者overflow不是visible，那么他的基线将在于margin底部，如果里面有文字，将于最后一行文字的基线对齐</li>
</ul>
</blockquote>
<h4 id="2-如何消除呢">2) 如何消除呢？</h4>
<blockquote>
<ul>
<li>设置父元素font-size为0，然后再把子元素的font-size恢复</li>
</ul>
</blockquote>
<h3 id="66-三列布局">6.6 三列布局</h3>
<h4 id="1-双飞翼布局">1) 双飞翼布局</h4>
<blockquote>
<ul>
<li>两侧宽度固定，中间宽度自适应</li>
<li>中间的dom优先渲染</li>
<li>允许三列中任意一列成为最高列</li>
<li>额外使用了一个div标签，该div是用来取得内层center的宽度了，避免计算calc(100%-350px)</li>
<li>margin-left: -100%; //使得左栏放到上一行的最左边</li>
<li>margin-left: -右栏宽度; //使得右栏放到上一行的最右边</li>
<li>为了避免中间栏被挤掉，需要设置body的最小宽度</li>
</ul>
</blockquote>
<pre><code class="language-html"><div>        // main.html
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container column&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left column&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right column&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        // main.css
        @charset &quot;UTF-8&quot;;
        /**
         * 
         * @authors ${冰红茶} (${hblvsjtu@163.com})
         * @date    2019-07-31
         * @version $0.0.1$
         */
         
        body {
            min-width: 500px;
        }

        .column {
          float: left;
          height: 100px;
        }

        .container {
          width: 100%;
        }

        .container .center {
          height: 100%;
          margin-left: 200px;
          margin-right: 150px;
          background: red;
        }

        .left {
          width: 200px;
          margin-left: -100%;
          background: yellow; 
        }

        .right {
          width: 150px;
          margin-left: -150px;
          background: green; 
        }
</div></code></pre>
<blockquote>
<ul>
<li>不用div包裹内部center的版本 目前需要计算计算calc(100%-350px)，calc()支持到IE9。</li>
</ul>
</blockquote>
<pre><code class="language-html"><div>        // main.html
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center column&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left column&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right column&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        // main.css
        @charset &quot;UTF-8&quot;;
        /**
         * 
         * @authors ${冰红茶} (${hblvsjtu@163.com})
         * @date    2019-07-31
         * @version $0.0.1$
         */
         
        body {
            min-width: 350px; // 200px + 150px
        }

        .column {
            float: left;
            height: 100px;
        }

        .center {
            width: calc(100% - 200px - 150px);
            margin-left: 200px;
            margin-right: 150px;
            background: red;
        }

        .left {
            width: 200px;
            margin-left: -100%;
            background: yellow; 
        }

        .right {
            width: 150px;
            margin-left: -150px;
            background: green; 
        }
</div></code></pre>
<h4 id="2-圣杯布局">2) 圣杯布局</h4>
<blockquote>
<ul>
<li>多一个div作为container</li>
<li>container的左右padding为左右栏留出空位</li>
<li>左右栏使用relative作平移补偿</li>
</ul>
</blockquote>
<pre><code class="language-html"><div>        // main.html
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center column&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left column&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right column&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        // main.css
        @charset &quot;UTF-8&quot;;
        /**
         * 
         * @authors ${冰红茶} (${hblvsjtu@163.com})
         * @date    2019-07-31
         * @version $0.0.1$
         */
         
        body {
            min-width: 550px; // 200px+150px+200px
        }

        .container {
            padding-left: 200px;
            padding-right: 150px;
            height: 100px;
        }

        .column {
            float: left;
            height: 100%;
        }

        .center {
            width: 100%;
            background: red;
        }

        .left {
            position: relative;
            left: -200px;
            width: 200px;
            margin-left: -100%;
            background: yellow; 
        }

        .right {
            position: relative;
            right: -150px;
            width: 150px;
            margin-left: -150px;
            background: green; 
        }
</div></code></pre>
<h4 id="3-简单float布局">3) 简单float布局</h4>
<blockquote>
<ul>
<li>左右分别来一个float，中间用margin撑开</li>
<li>center只能放在下面，否则会挤掉left和right</li>
<li>缺点：center最后才渲染，而且center的文字流会收到left和right的影响</li>
</ul>
</blockquote>
<pre><code class="language-html"><div>        // main.html
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        // main.css
        @charset &quot;UTF-8&quot;;
        /**
         * 
         * @authors ${冰红茶} (${hblvsjtu@163.com})
         * @date    2019-07-31
         * @version $0.0.1$
         */

        body {
            min-width: 350px;
        }

        .center {
            height: 100px;
            margin-left: 200px;
            margin-right: 150px;
            background: red;
        }

        .left {
            float: left;
            width: 200px;
            height: 100px;
            background: yellow; 
        }

        .right {
            float: right;
            width: 150px;
            height: 100px;
            background: green; 
        }
</div></code></pre>
<h4 id="4-绝对float布局">4) 绝对float布局</h4>
<blockquote>
<p>多一个div作为包裹
简单易用，兼容性好
中间最先出</p>
</blockquote>
<pre><code class="language-html"><div>        // main.html
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        // main.css
        @charset &quot;UTF-8&quot;;
        /**
         * 
         * @authors ${冰红茶} (${hblvsjtu@163.com})
         * @date    2019-07-31
         * @version $0.0.1$
         */

        body {
            min-width: 350px;
        }

        .container {
            position: relative;
            height: 100px;
            overflow: hidden;
        }

        .center {
            position: absolute;
            left: 200px;
            right: 150px;
            top: 0;
            bottom: 0;
            background: red;
        }

        .left {
            float: left;
            width: 200px;
            height: 100px;
            background: yellow; 
        }

        .right {
            float: right;
            width: 150px;
            height: 100px;
            background: green; 
        }
</div></code></pre>
<h4 id="5-绝对布局">5) 绝对布局</h4>
<blockquote>
<p>多一个div作为包裹
简单易用，兼容性好
中间最先出</p>
</blockquote>
<pre><code class="language-html"><div>        // main.html
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        // main.css
        @charset &quot;UTF-8&quot;;
        /**
         * 
         * @authors ${冰红茶} (${hblvsjtu@163.com})
         * @date    2019-07-31
         * @version $0.0.1$
         */

        body {
            min-width: 350px;
        }

        .container {
            position: relative;
            height: 100px;
        }

        .center {
            position: absolute;
            left: 200px;
            right: 150px;
            top: 0;
            bottom: 0;
            background: red;
        }

        .left {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            float: left;
            width: 200px;
            background: yellow; 
        }

        .right {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 150px;
            background: green; 
        }
</div></code></pre>
<h3 id="67-弹性布局">6.7 弹性布局</h3>
<h4 id="1-容器">1) 容器</h4>
<blockquote>
<ul>
<li>display: flex;    // 将块级元素设置为容器</li>
<li>display: inline-flex    // 将行内元素设置为容器</li>
<li>当元素设置成弹性容器后，它的所有子元素变成弹性项目此时项目的float/clear/vertical-align属性会失效</li>
</ul>
</blockquote>
<h4 id="2-主轴方向flex-direction">2) 主轴方向：flex-direction:</h4>
<blockquote>
<ul>
<li>row，默认值，主轴是x轴，主轴起点是左端</li>
<li>row-reverse,  主轴是x轴，主轴起点是右端</li>
<li>column，主轴是y轴，主轴起点在顶部</li>
<li>column-reverse,主轴是y轴，主轴起点在底部</li>
</ul>
</blockquote>
<h4 id="3-换行显示flex-wrap">3) 换行显示：flex-wrap</h4>
<blockquote>
<ul>
<li>nowrap 默认值，空间不够时，也不换行，项目自动缩小</li>
<li>wrap 空间不够就换行</li>
<li>wrap-reverse 换行，并反转</li>
</ul>
</blockquote>
<h4 id="4-flex-flow">4) flex-flow</h4>
<blockquote>
<ul>
<li>flex-direction + flex-wrap</li>
</ul>
</blockquote>
<h4 id="5-定义项目在主轴上的对齐方式justify-content">5) 定义项目在主轴上的对齐方式：justify-content</h4>
<blockquote>
<ul>
<li>flex-start,默认值，以主轴起点对齐</li>
<li>flex-end，以主轴终点对齐</li>
<li>center  在主轴上居中对齐</li>
<li>space-between 两端对齐，两端无空白</li>
<li>space-around 每个间距大小相同，两边会留白</li>
</ul>
</blockquote>
<h4 id="6-定义项目在交叉轴上的对齐方式align-items">6) 定义项目在交叉轴上的对齐方式：align-items</h4>
<blockquote>
<ul>
<li>flex-start 交叉轴起点对齐</li>
<li>flex-end 交叉轴终点对齐</li>
<li>center 交叉轴居中对齐</li>
<li>baseline 交叉轴基线对齐，就是交叉轴起点</li>
<li>stretch 前提，项目不写高。占满交叉轴上所有的空间</li>
</ul>
</blockquote>
<h4 id="7-项目中的属性">7) 项目中的属性</h4>
<blockquote>
<ul>
<li>order 定义项目排列顺序，值越小，越靠近起点，默认值为0</li>
<li>flex-grow 定义项目的放大比例 取值：无单位整数，默认值0，不放大</li>
<li>flex-shrink 定义项目缩小的比例，容器空间不足时，项目该如何缩小。默认值为1。 取值为0，不缩小。取值越大，缩小越快。</li>
<li>flex-basis 主轴存在剩余空间时，分配给此项目多少空间，默认auto即本身宽度</li>
<li>flex: 默认值是 0 1 auto</li>
</ul>
</blockquote>
<h4 id="7-align-self">7) align-self</h4>
<blockquote>
<ul>
<li>子项目自身的交叉轴对齐方式，会覆盖容器的align-item属性</li>
</ul>
</blockquote>
<h4 id="8-flex-grow和flex-shrink相关计算公式">8) flex-grow和flex-shrink相关计算公式</h4>
<blockquote>
<ul>
<li>子元素空间 &lt; 父容器</li>
</ul>
</blockquote>
<pre><code>    父容器剩余空间 = 父容器宽度 - 子元素宽度之和
    增长单位 = 父容器剩余空间 / 各子元素flex-grow之和
    子元素实际宽度 = (flex-basis) + 增长单位 * (flex-grow)
</code></pre>
<blockquote>
<ul>
<li>子元素空间 &gt; 父容器</li>
</ul>
</blockquote>
<pre><code>    子元素溢出的宽度 = 子元素的宽度之和 - 子元素宽度之和
    收缩单位 = 子元素溢出的宽度 / 各子元素flex_shrink之和
    计算的子元素的宽度 = (flex-basis) - 收缩单位*(flex-shrink)
</code></pre>
<h4 id="9-手写一个圣杯布局">9) 手写一个圣杯布局</h4>
<blockquote>
<ul>
<li>包括header,nav,main,aside,footer</li>
</ul>
</blockquote>
<pre><code class="language-html"><div>        // mian.html
        <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>header<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>main<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span>nav<span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&gt;</span>aside<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>footer<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>


        // mian.css
        @charset &quot;UTF-8&quot;;
        /**
         * 
         * @authors ${冰红茶} (${hblvsjtu@163.com})
         * @date    2019-07-31
         * @version $0.0.1$
         */

        body {
            display: flex;
            flex-flow: column wrap; 
            min-width: 350px;
            min-height: 500px;
            height: 100%;
        }

        header,
        footer {
            display: flex;
            justify-content: center;
            align-items: center;
            flex: 0 0 100px;
            background: gray;
        }

        header {
            order: 1;
        }

        footer {
            order: 3;
        }

        .container {
            display: flex;
            flex-flow: row nowrap;
            order: 2;
            flex: 1 1 auto;
        }

        .container main {
            order: 2;
            flex: 1 1 auto;
            background: red;
        }

        .container nav {
            order: 1;
            flex: 0 0 200px;
            background: yellow;
        }

        .container aside {
            order: 3;
            flex: 0 0 150px;
            background: green;
        }

        .container main,
        .container nav,
        .container aside {
            display: flex;
            justify-content: center;
            align-items: center;
        }
</div></code></pre>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p><img src="https://github.com/hblvsjtu/FET/blob/master/picture/%E5%9B%BE6-2%20flex%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80.png?raw=true" alt="图6-2 flex圣杯布局"></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h3 id="68-响应式布局">6.8 响应式布局</h3>
<h4 id="1-null-1">1) null</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<h3 id="69-变形动画">6.9 变形动画</h3>
<h4 id="1-二维动画">1) 二维动画</h4>
<blockquote>
<ul>
<li>引自<a href="https://segmentfault.com/a/1190000015236871">落霞与孤鹜齐飞</a></li>
</ul>
</blockquote>
<pre><code class="language-html"><div>        transform: translate(x, y); 沿着 X 和 Y 轴移动元素。
        transform: translate(100px, 100px);

        transform: rotate(angle); 旋转元素。
        transform: rotate(45deg);

        transform: scale(x, y); 倍数改变元素的宽度和高度。
        transform: scale(2, 3);

        transform: skew(x, y); 沿着 X 和 Y 轴倾斜。
        transform: skew(45deg, -45deg);

        transform-origin: x y; 旋转的基点位置（默认center center）。
        transform-origin: right bottom;

        transform: translateX(45px) rotate(45deg); 合并简写
</div></code></pre>
<h4 id="2-三维动画">2) 三维动画</h4>
<blockquote>
<ul>
<li>引自<a href="https://segmentfault.com/a/1190000015236871">落霞与孤鹜齐飞</a></li>
<li>preserve-3d：保证所有子元素都处于同一个三维空间</li>
<li>perspective定义摄像机（也就是作为观众的我们）到屏幕的距离</li>
<li>perspective-origin定义摄像机观察到的画面中的灭点（vanishing point）的位置</li>
</ul>
</blockquote>
<pre><code class="language-html"><div>        transform-style: preserve-3d;
        perspective: 24px;  设置元素被查看位置的视图  
        perspective-oragin: center center; 改变视点的位置

        transform: translate3d();
        transform: translateX();
        transform: translateY();
        transform: translateZ();

        transform: rotate3d();
        transform: rotateX();
        transform: rotateY();
        transform: rotateZ();

        transform: scale3d();
        transform: scaleX();
        transform: scaleY();
        transform: scaleZ();
</div></code></pre>
<h3 id="610-补间动画">6.10 补间动画</h3>
<h4 id="1-null-2">1) null</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<hr>
<h2 id="九浏览器篇">九、浏览器篇</h2>
<h3 id="93-defer和async的区别">9.3 defer和async的区别</h3>
<h4 id="1-相同点-1">1) 相同点</h4>
<blockquote>
<ul>
<li>都用在script的异步脚本加载中，</li>
</ul>
</blockquote>
<h4 id="2-不同点-1">2) 不同点</h4>
<blockquote>
<ul>
<li>脚本的执行时间和执行顺序</li>
<li>async的脚本是看那个脚本最先下载完成先执行，跟写在HTML上的顺序是不同的</li>
<li>defer实在DOM解析完成后，DOMContentLoaded 事件触发之前完成的，一般是按照写在HTML上的顺序执行，但是实际体验下来这个顺序不能保证</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p><img src="https://github.com/hblvsjtu/FET/blob/master/picture/%E5%9B%BE9-1%20async%E5%92%8Cdefer%E7%9A%84%E5%8C%BA%E5%88%AB.png?raw=true" alt="图9-1 async和defer的区别"></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h3 id="95-浏览器性能和计时器">9.5 浏览器性能和计时器</h3>
<h4 id="1-高消耗的样式">1) 高消耗的样式</h4>
<blockquote>
<ul>
<li>box-shadows</li>
<li>border-radius</li>
<li>transparency</li>
<li>transforms</li>
<li>CSS filters（性能杀手）</li>
</ul>
</blockquote>
<h4 id="2-减少重排reflow的经验">2) 减少重排Reflow的经验</h4>
<blockquote>
<ul>
<li>不要逐条修改CSS样式，最好预先写成class，再使用dom.classList.add()</li>
<li>离线修改DOM: 先把 DOM 给 display:none, 再把它还原；</li>
<li>为动画的元素使用绝对定位 absolute / fixed</li>
<li>不要使用 table 布局</li>
</ul>
</blockquote>
<h4 id="3-优化动画性能">3) 优化动画性能</h4>
<blockquote>
<ul>
<li>GPU （Graphics Processing Unit） 是图像处理器，再处理图像上更加有效率</li>
<li>GPU加速可以不仅应用于3D，而且也可以应用于2D，常用的场合：Canvas2D，布局合成（Layout Compositing）, CSS3转换（transitions），CSS3 3D变换（transforms），WebGL和视频(video)。</li>
<li>所以如果需要提升transforms的性能，可以强制为它开启3D，如transform: translate3d(10px, 10px, 0);</li>
<li>或者使用&quot;transform:translateZ(0);</li>
</ul>
</blockquote>
<pre><code class="language-css"><div>        <span class="hljs-selector-class">.cube</span> { 
            <span class="hljs-attribute">-webkit-transform</span>: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0</span>); 
            <span class="hljs-attribute">-moz-transform</span>: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0</span>); 
            <span class="hljs-attribute">-ms-transform</span>: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0</span>); 
            <span class="hljs-attribute">-o-transform</span>: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0</span>); 
            <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0</span>);
        }
</div></code></pre>
<blockquote>
<ul>
<li>在 Chrome 和 Safari中， 以下声明可以解决转换或动画可能会看到闪烁的效果</li>
</ul>
</blockquote>
<pre><code class="language-css"><div>        <span class="hljs-selector-class">.cube</span> { 
            <span class="hljs-attribute">-webkit-backface-visibility</span>: hidden;
            <span class="hljs-attribute">-moz-backface-visibility</span>: hidden;
            <span class="hljs-attribute">-ms-backface-visibility</span>: hidden;
            <span class="hljs-attribute">backface-visibility</span>: hidden;
            <span class="hljs-attribute">-webkit-perspective</span>: <span class="hljs-number">1000</span>;
            <span class="hljs-attribute">-moz-perspective</span>: <span class="hljs-number">1000</span>;
            <span class="hljs-attribute">-ms-perspective</span>: <span class="hljs-number">1000</span>;
            <span class="hljs-attribute">perspective</span>: <span class="hljs-number">1000</span>;
        }
</div></code></pre>
<blockquote>
<ul>
<li>那问题来了，为什么开启3D来打开GPU加速可以优化动画性能呢？因为浏览器DOM渲染需要经过重排和重绘两个过程，其中重排的消耗最大。那问题就来到如果减少重排和重绘，甚至避免重排和重绘，借此提高动画的性能。动画是有帧组成的连续画面，开启GPU加速，即是GPU计算'层'，或者叫「纹理」，实际上是是DOM快照，通过已知变换矩阵来修改'层'，实质上是位图，来避免DOM的重排和重绘。</li>
<li>那问题又来了：什么情况下会触发层的创建呢？引自<a href="https://github.com/ccforward/cc/issues/42">chokcoco的回答</a></li>
</ul>
<blockquote>
<ul>
<li>3D 或透视变换(perspective、transform) CSS 属性</li>
<li>使用加速视频解码的 元素</li>
<li>拥有 3D (WebGL) 上下文或加速的 2D 上下文的 元素</li>
<li>混合插件(如 Flash)</li>
<li>对自己的 opacity 做 CSS 动画或使用一个动画变换的元素</li>
<li>拥有加速 CSS 过滤器的元素， 如：</li>
</ul>
</blockquote>
</blockquote>
<pre><code class="language-css"><div>        <span class="hljs-selector-tag">filter</span>: <span class="hljs-selector-tag">brightness</span>(50%); // 明度滤镜
        <span class="hljs-selector-tag">filter</span>: <span class="hljs-selector-tag">saturate</span>(1000%); // 饱和度滤镜
        <span class="hljs-selector-tag">filter</span>: <span class="hljs-selector-tag">blur</span>(5<span class="hljs-selector-tag">px</span>); // 模糊滤镜
        <span class="hljs-selector-tag">filter</span>: <span class="hljs-selector-tag">hue-rotate</span>(45<span class="hljs-selector-tag">deg</span>); // 色相反转滤镜
        <span class="hljs-selector-tag">filter</span>: <span class="hljs-selector-tag">invert</span>(100%); // 颜色反转滤镜
        <span class="hljs-selector-tag">filter</span>: <span class="hljs-selector-tag">contrast</span>(25%); // 对比度滤镜
        <span class="hljs-selector-tag">filter</span>: <span class="hljs-selector-tag">drop-shadow</span>(5<span class="hljs-selector-tag">px</span> 5<span class="hljs-selector-tag">px</span> 5<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">red</span>); //阴影滤镜 第一个值是<span class="hljs-selector-tag">X</span>方向上的位移，第二个值是<span class="hljs-selector-tag">Y</span>轴方向上的位移，第三个值是模糊的大小，第四个值是模糊的颜色。
</div></code></pre>
<blockquote>
<blockquote>
<ul>
<li>元素有一个包含复合层的后代节点，换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)</li>
<li>元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染</li>
</ul>
</blockquote>
</blockquote>
<hr>
<h2 id='10'>十、V8引擎篇
### 10.0 事件循环
<h4 id="1-主线程">1) 主线程</h4>
<blockquote>
<ul>
<li>JS异步单线程里面的单线程指的是就是主线程，或者平常所说的『main』函数</li>
</ul>
</blockquote>
<h4 id="2-任务队列macrotasks">2) 任务队列(Macrotasks)</h4>
<blockquote>
<ul>
<li>当主线程在运作的时候，异步方法在指定的事件发生后，就会保存到一个队列中；当主线程在空闲时的时候，系统将会遍历该队列里面的方法并一一顺序执行。此队列就是'任务队列'。</li>
<li>比如dom事件、setTimeout、setInterval、ajax事件</li>
</ul>
</blockquote>
<h4 id="3-微任务队列microtasks">3) 微任务队列(Microtasks)</h4>
<blockquote>
<ul>
<li>就是在主线程和任务队列隔着的一层队列，当主线程空闲时，先遍历微任务队列并把里面的任务一一顺序执行，再遍历任务队列并一一顺序执行里面的方法。</li>
<li>如promise、process.nextTicks、MutationObserver</li>
</ul>
</blockquote>

    </body>
    </html>