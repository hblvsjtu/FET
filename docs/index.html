<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>FET</title>
        <style>
</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </head>
    <body class="vscode-light">
        <h1 id="fet">FET</h1>
<h2 id="作者冰红茶">作者：冰红茶</h2>
<hr>
<p>平常在生活中或者工作中不断的学习前端知识，记录和分享吾之所见吾之所悟^_ ^</p>
<h2 id="目录">目录</h2>
<h2 id="一类型判断篇"><a href="#1">一、类型判断篇</a></h2>
<h3 id="11-基本数据类型"><a href="#1.1">1.1 基本数据类型</a></h3>
<h3 id="12-对象类型系统"><a href="#1.2">1.2 对象类型系统</a></h3>
<h3 id="13-平台"><a href="#1.3">1.3 平台</a></h3>
<h2 id="二常用方法篇"><a href="#2">二、常用方法篇</a></h2>
<h3 id="21-拷贝"><a href="#2.1">2.1 拷贝</a></h3>
<h3 id="22-类数组判断与转化"><a href="#2.2">2.2 类数组判断与转化</a></h3>
<h3 id="23-数组去重"><a href="#2.3">2.3 数组去重</a></h3>
<h3 id="24-数组洗牌"><a href="#2.4">2.4 数组洗牌</a></h3>
<h3 id="25-数组排序"><a href="#2.5">2.5 数组排序</a></h3>
<h3 id="26-最大重复子序列"><a href="#2.6">2.6 最大重复子序列</a></h3>
<h3 id="27-最大重复子数组"><a href="#2.7">2.7 最大重复子数组</a></h3>
<h3 id="28-ajax封装"><a href="#2.8">2.8 ajax封装</a></h3>
<h3 id="29-stringformat"><a href="#2.9">2.9 String.format</a></h3>
<h3 id="210-stringthousandsplit"><a href="#2.10">2.10 String.thousandSplit</a></h3>
<h2 id="三原理实现篇"><a href="#3">三、原理实现篇</a></h2>
<h3 id="31-callapplybind"><a href="#3.1">3.1 call/apply/bind</a></h3>
<h3 id="32-deferred和promise"><a href="#3.2">3.2 Deferred和Promise</a></h3>
<h3 id="33-asyncawait"><a href="#3.3">3.3 async/await</a></h3>
<h3 id="34-观察者模式"><a href="#3.4">3.4 观察者模式</a></h3>
<h3 id="35-防抖动和截流"><a href="#3.5">3.5 防抖动和截流</a></h3>
<h3 id="36-类的继承"><a href="#3.6">3.6 类的继承</a></h3>
<h3 id="37-new"><a href="#3.7">3.7 new</a></h3>
<h3 id="38-objectcreate"><a href="#3.8">3.8 Object.create()</a></h3>
<h3 id="39-objectkeysobjectvaluesobjectentries"><a href="#3.9">3.9 Object.keys/Object.values/Object.entries</a></h3>
<h3 id="310-settimeout-与-setinterval"><a href="#3.10">3.10 setTimeout 与 setInterval</a></h3>
<h3 id="311-跨域"><a href="#3.11">3.11 跨域</a></h3>
<h3 id="312-函数柯里化"><a href="#3.12">3.12 函数柯里化</a></h3>
<h3 id="313-高阶函数"><a href="#3.13">3.13 高阶函数</a></h3>
<h2 id="四正则表达式篇"><a href="#4">四、正则表达式篇</a></h2>
<h3 id="41-断言"><a href="#4.1">4.1 断言</a></h3>
<h3 id="42-分组"><a href="#4.2">4.2 分组</a></h3>
<h3 id="43-非贪婪"><a href="#4.3">4.3 非贪婪</a></h3>
<h3 id="44-电话号码身份证网址邮箱"><a href="#4.4">4.4 电话号码/身份证/网址/邮箱</a></h3>
<h2 id="五js和html效果篇"><a href="#5">五、js和html效果篇</a></h2>
<h3 id="51-获取元素样式位置尺寸"><a href="#5.1">5.1 获取元素样式/位置/尺寸</a></h3>
<h3 id="52-拖拽"><a href="#5.2">5.2 拖拽</a></h3>
<h3 id="53-图片懒加载"><a href="#5.3">5.3 图片懒加载</a></h3>
<h3 id="54-轮播"><a href="#5.4">5.4 轮播</a></h3>
<h3 id="55-滑动"><a href="#5.5">5.5 滑动</a></h3>
<h3 id="56-级联"><a href="#5.6">5.6 级联</a></h3>
<h3 id="57-图片剪裁"><a href="#5.7">5.7 图片剪裁</a></h3>
<h3 id="58-图片压缩"><a href="#5.8">5.8 图片压缩</a></h3>
<h3 id="59-tab"><a href="#5.9">5.9 Tab</a></h3>
<h2 id="六css效果篇"><a href="#5">六、CSS效果篇</a></h2>
<h3 id="61-水平居中"><a href="#6.1">6.1 水平居中</a></h3>
<h3 id="62-垂直居中"><a href="#6.2">6.2 垂直居中</a></h3>
<h3 id="63-水平垂直居中"><a href="#6.3">6.3 水平垂直居中</a></h3>
<h3 id="64-清除浮动"><a href="#6.4">6.4 清除浮动</a></h3>
<h3 id="65-消除幽灵空格"><a href="#6.5">6.5 消除幽灵空格</a></h3>
<h3 id="66-三列布局"><a href="#6.6">6.6 三列布局</a></h3>
<h3 id="67-弹性布局"><a href="#6.7">6.7 弹性布局</a></h3>
<h3 id="68-响应式布局"><a href="#6.8">6.8 响应式布局</a></h3>
<h3 id="69-变形动画"><a href="#6.9">6.9 变形动画</a></h3>
<h3 id="610-补间动画"><a href="#6.10">6.10 补间动画</a></h3>
<h2 id="七前端工程化和模块化篇"><a href="#7">七、前端工程化和模块化篇</a></h2>
<h3 id="71-npm"><a href="#7.1">7.1 npm</a></h3>
<h3 id="72-webpack"><a href="#7.2">7.2 Webpack</a></h3>
<h3 id="73-bable"><a href="#7.3">7.3 Bable</a></h3>
<h3 id="74-lint"><a href="#7.4">7.4 Lint</a></h3>
<h3 id="75-常见的模块化协议"><a href="#7.5">7.5 常见的模块化协议</a></h3>
<h2 id="八计算机网络篇"><a href="#8">八、计算机网络篇</a></h2>
<h3 id="81-五层网络和七层网络"><a href="#8.1">8.1 五层网络和七层网络</a></h3>
<h3 id="82-三次握手和四次挥手"><a href="#8.2">8.2 三次握手和四次挥手</a></h3>
<h3 id="83-tcp与udp"><a href="#8.3">8.3 TCP与UDP</a></h3>
<h3 id="84-http与https协议"><a href="#8.4">8.4 HTTP与HTTPS协议</a></h3>
<h3 id="85-http状态码"><a href="#8.5">8.5 HTTP状态码</a></h3>
<h3 id="86-常见的网络安全问题"><a href="#8.6">8.6 常见的网络安全问题</a></h3>
<h2 id="九浏览器篇"><a href="#8">九、浏览器篇</a></h2>
<h3 id="91-访问一个链接发生的全过程"><a href="#9.1">9.1 访问一个链接发生的全过程</a></h3>
<h3 id="92-浏览器渲染过程"><a href="#9.2">9.2 浏览器渲染过程</a></h3>
<h3 id="93-defer和ansys的区别"><a href="#9.3">9.3 defer和ansys的区别</a></h3>
<h3 id="94-ie的hack写法"><a href="#9.4">9.4 IE的hack写法</a></h3>
<h3 id="95-浏览器性能和计时器"><a href="#9.5">9.5 浏览器性能和计时器</a></h3>
<h3 id="96-http状态码"><a href="#9.6">9.6 HTTP状态码</a></h3>
<h3 id="97-常见的网络安全问题"><a href="#9.7">9.7 常见的网络安全问题</a></h3>
<h2 id="十v8引擎篇"><a href="#10">十、V8引擎篇</a></h2>
<h3 id="100-事件循环"><a href="#10.1">10.0 事件循环</a></h3>
<hr>
<h2 id='1'>一、类型判断篇</h2>
<h3 id='1.1'>1.1 基本数字类型</h3>
<h4 id="1-null">1) null</h4>
<blockquote>
<ul>
<li>直接跟v他自己比较即可</li>
</ul>
</blockquote>
<pre><code>            function isNull(o) {
                return o === null;
            }
</code></pre>
<h4 id="2-nan">2) NaN</h4>
<blockquote>
<ul>
<li>因为它连跟它自己比较都不相等，可以用此特性进行判断</li>
</ul>
</blockquote>
<pre><code>            function isNaN(o) {
                return o !== o;
            }
</code></pre>
<h4 id="3-undefined">3) undefined</h4>
<blockquote>
<ul>
<li>undefined它并不是一个保留词，他是全局对象的一个属性，这说明什么呢？说明它有可能会被改写。到了ES5被改成只读了，但是在局部作用域中还是会被改写，虽然在最新的chrome 75.0.3770.142中我并没有发现改写-.-||</li>
<li>为什么是void 0? 因为根据MDN的解释：The void operator evaluates the given expression and then returns undefined. 无论你给他赋什么的值，都会返回undefined，而0应该是最简单的喽</li>
</ul>
</blockquote>
<pre><code>            function isUndefined(o) {
                return o === void 0;
            }
</code></pre>
<h4 id="4-number">4) number</h4>
<blockquote>
<ul>
<li>采用鸭子辩型</li>
<li>因为如果纯粹使用typeof的话会把包装类也识别成对象；</li>
</ul>
</blockquote>
<pre><code>            function isNumber(o) {
                return '[object Number]' === {}.toString.call(o) &amp;&amp; isFinite(o); 
            }
</code></pre>
<h4 id="5-boolean">5) boolean</h4>
<blockquote>
<ul>
<li>采用鸭子辩型</li>
<li>因为如果纯粹使用typeof的话会把包装类也识别成对象；</li>
</ul>
</blockquote>
<pre><code>            function isboolean(o) {
                return '[object Boolean]' === {}.toString.call(o); 
            }
</code></pre>
<h3 id='1.2'>1.2 对象类型系统</h3>
<h4 id="1-object">1) object</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<pre><code>            function isObject(o) {
                return '[object Object]' === {}.toString.call(o); 
            }
</code></pre>
<h4 id="2-函数">2) 函数</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<pre><code>            function isFunction(o) {
                return '[object Function]' === {}.toString.call(o); 
            }
</code></pre>
<h4 id="3-正则表达式">3) 正则表达式</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<pre><code>            function isRegExp(o) {
                return '[object RegExp]' === {}.toString.call(o); 
            }
</code></pre>
<h4 id="4-日期">4) 日期</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<pre><code>            function isDate(o) {
                return '[object Date]' === {}.toString.call(o); 
            }
</code></pre>
<h4 id="5-数组">5) 数组</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<pre><code>            function isArray(o) {
                return '[object Array]' === {}.toString.call(o); 
            }
</code></pre>
<h4 id="6-全类型判断">6) 全类型判断</h4>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */

            function type(o) {
                if(o === null) return &quot;null&quot;;
                else if(o !== o) return &quot;NaN&quot;;
                else if(o === void 0) return &quot;undefined&quot;;
                else {
                    let type = {}.toString.call(o).slice(8, -1);
                    return type ? type : '它不是基本类型'
                }
            }
</code></pre>
<h3 id='1.3'>1.3 平台</h3>
<h4 id="1-window">1) window</h4>
<blockquote>
<ul>
<li>需要区分不同的平台</li>
<li>IE6、7、8利用window == document为真 但是document == window为假的神奇特性</li>
<li>标准浏览器及IE9,IE10等使用鸭子辩型的方法</li>
</ul>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */

            // IE6、7、8
            function isWindow(obj) {
                return obj == obj.document &amp;&amp; obj.document != obj;
            }
            // 标准浏览器及IE9,IE10
            function isWindow(obj) {
                return /^\[object (Window|DOMWindow|global)/.test({}.toString.call(obj));
            }
</code></pre>
<h4 id="2浏览器">2）浏览器</h4>
<blockquote>
<ul>
<li>判断浏览器类型</li>
<li>利用navigator.userAgent来判断</li>
<li>要把browsers数组里面的子项按照顺序来放，因为有时候userAgent里面会同时出现两种或以上的子项，当Safari出现的时候一般在userAgent的最后面，而&quot;Chrome&quot;次之，所以需要把他们放在前面先进行遍历</li>
</ul>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */

            function myBrowser(){
                var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串
                // 此处要把
                let browsers = [&quot;Safari&quot;, &quot;Opera&quot;, &quot;Firefox&quot;, &quot;Chrome&quot;, &quot;Edge&quot;, &quot;compatible&quot;];
                let browser = '';
                browsers.forEach(item =&gt; {
                    if(userAgent.indexOf(item) &gt; -1)
                        browser = item;
                })
                if(browser === &quot;compatible&quot;) {
                    if(browser =userAgent.match(/(?:MSIE\s*)\d{1,2}.0(?=\s*;)/)) {
                        browser = browser[0].replace('MS', '')
                    }
                }
                return browser;
            }             
</code></pre>
<hr>
<h2 id='2'>二、常用方法篇</h2>
<h3 id='2.1'>2.1 拷贝</h3>
<h4 id="1-数组浅拷贝">1) 数组浅拷贝</h4>
<blockquote>
<ul>
<li>Object.assign</li>
<li></li>
</ul>
</blockquote>
<h4 id="2-数组深拷贝">2) 数组深拷贝</h4>
<blockquote>
<ul>
<li>先对输入进行判断，是数组、对象还是其他</li>
<li>然后如果是数组或者对象的时候进行遍历，子元素是数组或者对象的时候直接赋值，否则进行递归</li>
</ul>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */

            let deepCopy = function(obj) {
                let o;
                let type = Object.prototype.toString.call(obj);
                if(type === '[object Array]' || type === '[object Object]') {
                    o = type === '[object Array]' ? [] : {};
                    for(let key in obj) {
                        if(obj.hasOwnProperty(key)) {
                            if(typeof obj[key] === 'Object') {       
                                o[key] = deepCopy(obj[key]);
                            }
                            else {
                                o[key] = obj[key];
                            }
                        }
                    }
                }
                else {
                    o = obj;
                }
                return o;
            };
</code></pre>
<h3 id='2.2'>2.2 类数组判断与转化</h3>
<h4 id="1-判断">1) 判断</h4>
<blockquote>
<ul>
<li>是一个对象</li>
<li>有length属性</li>
<li>length属性的值是一个非负有限整数</li>
</ul>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */

            function isArrayLike(obj) {
                return obj &amp;&amp; (typeof obj === 'object') &amp;&amp;  (obj.length &gt;= 0) &amp;&amp;  obj.length &lt; 4294967296 &amp;&amp; (obj.length === Math.floor(obj.length))
            }
</code></pre>
<h4 id="2-slice的内部实现">2) slice的内部实现</h4>
<blockquote>
<ul>
<li>返回一个数组</li>
<li>循环赋值从0到length</li>
</ul>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */

            //slice的内部实现
            Array.prototype.slice = function(start,end){  
                  var result = new Array();  
                  start = start || 0;  
                  end = end || this.length; //this指向调用的对象，当用了call后，能够改变this的指向，也就是指向传进来的对象，这是关键  
                  for(var i = start; i &lt; end; i++){  
                       result.push(this[i]);  
                  }  
                  return result;  
             }
</code></pre>
<h4 id="3-转化">3) 转化</h4>
<blockquote>
<ul>
<li>利用slice方法 [].slice.call(a);</li>
<li>Array.from();</li>
<li>手动转化</li>
</ul>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */

            function transfer(obj) {
                let arr = [];
                let l = obj.length;
                while(l &gt; 0) arr[--l] = obj[l];
                return arr;
            }
</code></pre>
<h3 id='2.4'>2.4 数组乱序</h3>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */

            shuffle = function(arr) {
                let temp = 0;
                let l = arr.length;
                let r = 0;
                for (let i = 0; i&lt;l; i++) {
                    r = Math.floor(Math.random() * (i + 1));
                    temp = arr[r];
                    arr[r] = arr[i];
                    arr[i] = temp;
                }
            }
            arr = [1,2,3,4,5,6];

            shuffle(arr);
            //[1, 4, 3, 5, 2, 6]
</code></pre>
<h3 id='2.8'>2.8 ajax封装</h3>
<h4 id="1-功能">1) 功能</h4>
<blockquote>
<ul>
<li></li>
<li></li>
</ul>
</blockquote>
<h3 id='2.9'>2.9 String.format</h3>
<h4 id="1-功能-1">1) 功能</h4>
<blockquote>
<ul>
<li>是一个函数挂载到String的原型上</li>
<li>相当于字符串模板</li>
<li>参数是模板的数据</li>
<li>分别用两个正则表达式切割关键词和非关键词，然后在进行拼接</li>
</ul>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */

            String.prototype.iFormat = function(data) {
                let keyArray = this.match(/(?&lt;=\$\{)\S+?(?=\})/g);
                let strArray = this.split(/\$\{\S+?\}/g);
                return strArray.map((item, index) =&gt; data[keyArray[index]] ? item + data[keyArray[index]] : item).join('');
            }

            let str = &quot;${a}ads${a}sad${b}as${c}zx${c}&quot;;
            str.iFormat({a: ' I ', b: ' love ', c: ' you '}); //&quot; I ads I sad love as you zx you &quot;
</code></pre>
<h4 id="2-一个更加简介的办法利用replace">2) 一个更加简介的办法：利用replace()</h4>
<blockquote>
<ul>
<li>第二个参数可以是函数，将每匹配到的一组分组就执行一次</li>
</ul>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */

            String.prototype.iFormat = function(transfer)   {
                return this.replace(/\$\{.+?\}/g, function(group){
                    return transfer[group.replace(/(^\$\{)|(\}$)/g, '')];
                })
            }

            let str = &quot;${a}ads${a}sad${b}as${c}zx${c}&quot;;
            str.iFormat({a: ' I ', b: ' love ', c: ' you '});
            // &quot; I ads I sad love as you zx you &quot;
</code></pre>
<h3 id='2.10'>2.10 String.thousandSplit</h3>
<h4 id="1-功能-2">1) 功能</h4>
<blockquote>
<ul>
<li>西方的数字从右往左每三位加一个分隔符</li>
</ul>
</blockquote>
<h4 id="2-实现">2) 实现</h4>
<blockquote>
<ul>
<li>需要零宽正向预言</li>
<li>$表示从右往左</li>
<li>，不能放在第一位</li>
<li>需要全局判断，因为不止匹配一个</li>
</ul>
</blockquote>
<pre><code>        /**
         * 
         * @authors ${冰红茶} (${hblvsjtu@163.com})
         * @date    2019-08-01
         * @version $Id$
         */

        String.prototype.thousandSplit = function(tag) {
            return this.replace(/(?&lt;=\B)(?=(\d{3})+$)/g, tag);
        }

        '234123456'.thousandSplit(',');
        // &quot;234,123,456&quot;
        '1234123456'.thousandSplit('$');
        // &quot;1$234$123$456&quot;
</code></pre>
<hr>
<h2 id='3'>三、原理实现篇</h2>
<h3 id='3.1'>3.1 call/apply/bind</h3>
<h4 id="1-call">1) call</h4>
<blockquote>
<ul>
<li>返回一个立即执行的函数</li>
<li>该函数的作用域被绑定为第一个形参</li>
<li>其他的形参作为原函数的参数</li>
<li>模拟的方法被绑定在函数的原型上，方便调用</li>
</ul>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */

            Function.prototype.myCall = function(content) {
                content.func = this; //转移this
                let arr = [], l = arguments.length;
                while(l &gt; 0) arr[--l] = arguments[l];
                arr.shift();
                return this(...arr);
            }

            let a = function(num, num1) {
                this.num = this.num ? this.num + num1 : num;
                console.log(this.num);
            }

            let b = {num: 1};

            a.myCall(b, 2, 3);

            // 4
</code></pre>
<h4 id="2-apply">2) apply</h4>
<blockquote>
<ul>
<li>根据call把参数改成数组输入的形式</li>
</ul>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */

            Function.prototype.myApply = function(content) {
                content.func = this; //转移this
                return content.func(...arguments[1]);
            }

            let a = function(num1, num2) {
                this.num = this.num ? this.num + num1 : num2;
                console.log(this.num);
            }

            let b = {num: 1};

            a.myApply(b, [2, 3]);

            // 3
</code></pre>
<h4 id="3-bind">3) bind</h4>
<blockquote>
<ul>
<li>返回一个函数</li>
<li>函数的作用域为bind的第一个参数</li>
<li>如果bind的参数不足够原函数消化，剩余的参数可以在返回的函数中输入</li>
<li>作为原型挂靠在Function上</li>
</ul>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */

            Function.prototype.myBind = function() {
                let self = this;
                let arr1 = Array.from(arguments);
                return function() {
                    let arr2 = arr1.concat(Array.from(arguments));
                    return self.call(...arr2);
                }
            }

            let a = function(num1, num2) {
                this.num = this.num ? this.num + num1 + num2 : num2;
                console.log(this.num);
            }

            let b = {num: 1};

            let c = a.myBind(b, 2);

            c(3);

            //6
            c(3);
            11
            c(3);
            16
</code></pre>
<h3 id='3.2'>3.2 Deferred和Promise</h3>
<h4 id="1-promisea规范">1) promise/A规范</h4>
<blockquote>
<ul>
<li>一个Promise对象有三种状态：未完成pendding，已完成Fulfilled和已拒绝Rejected</li>
<li>pendding可以转化成Fulfilled或者Rejected，但Fulfilled和Rejected不能相互转化</li>
<li>转化的过程是不可逆的</li>
<li>使用then方法可以返回promise进行链式调用</li>
<li>then方法的onFulfilled,onRejected 方法都是可选参数，且不是function，都被忽略</li>
</ul>
</blockquote>
<h4 id="2-deferredpromise">2) Deferred/promise</h4>
<blockquote>
<ul>
<li>这两个是合在一起的，这里的promise非ES6里面的Promise对象，注意这里的p是小写</li>
<li>Deferred更像是一个触发器</li>
<li>promise的then方法用来传递handlerQueue序列，handlerQueue是由每个then方法里面resolve和reject组成的handler集合</li>
<li>Deferred的resolve和reject遍历handlerQueue序列里面的handler，如果返回的结果是一个promise，就的Deferred的promise更新为返回的结果，如果不是的话就将结果作为下次resolve的实参。注意的是每遍历一个元素都需要把handlerQueue去掉相应的handler</li>
</ul>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */

            let promise = function() {
                this.handlerQueue = [];
            }

            promise.prototype.then = function(resolve, reject) {
                let handler = {};
                if(resolve &amp;&amp; typeof resolve === 'function') 
                    handler.resolve = resolve;
                if(reject &amp;&amp; typeof reject === 'function') 
                    handler.reject = reject;
                this.handlerQueue.push(handler);
                return this;
            }

            let Deferred = function() {
                this.state = 'pending';
                if(!this.promise) {
                    this.promise = new promise();
                }
            }

            Deferred.prototype.resolve = function(data) {
                this.state = 'resolve';
                let handlerQueue = this.promise.handlerQueue;
                let res;
                let handler;
                while(handler = handlerQueue.shift()) {
                    if (handler &amp;&amp; handler.resolve) {
                        res = handler.resolve(data);
                        if (res &amp;&amp; res instanceof promise) {
                            res.handlerQueue = handlerQueue;
                            let p = new promise();
                            p.handlerQueue = handlerQueue;
                            this.promise = p;
                        }
                        else if(res) {
                            data = res;
                        }
                    }
                }
            }

            Deferred.prototype.reject = function(data) {
                this.state = 'reject';
                let handlerQueue = this.promise.handlerQueue;
                let res;
                let handler;
                while(handler = handlerQueue.shift()) {
                    if (handler &amp;&amp; handler.reject) {
                        res = handler.reject(data);
                        if (res &amp;&amp; res instanceof promise) {
                            res.handlerQueue = handlerQueue;
                            this.promise = res;
                            return; // 这里还是有问题，如果返回的是一个promise会直接中断运行
                        }
                        else if(res) {
                            data = res;
                        }
                    }
                }
            }

            //------ test-------//
            function asyncDosomeing(flag, name) {
                const deferred = new Deferred()
                setTimeout(function () {
                    if (flag) {
                        deferred.resolve({code: 200, message: '成功', name: name})
                    } else {
                        deferred.reject({code: 400, message: '失败', name: name})
                    }
                }, 2000)
                return deferred.promise
            }
            asyncDosomeing(true, 'asyncDosomeing1').then(result =&gt; {
                console.info(result)
                return asyncDosomeing(false, 'asyncDosomeing2')
            }).then(result =&gt; {
                console.info(result)
                return 'dadds'
            }).then(result =&gt; {
                console.info(result)
            })
</code></pre>
<h4 id="2-promise第一次自己写的">2) Promise(第一次自己写的)</h4>
<blockquote>
<ul>
<li>Promise是Deferred/promise的混合版</li>
<li>Promise既作触发器又做储存器</li>
<li>需要在resolve和reject上包装，已达到窃听的效果</li>
<li>实现resolve和reject原型方法</li>
<li>如果返回值是空类型，则正常返回this作链式调用，如果返回值非空也非Promise类型，则作为参数传到下一个then，可惜这个我实现不了</li>
</ul>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */
            let MyPromise = function(fn) {
                this.status = 'unfulfilled';
                this.fn = typeof fn === 'function' ? fn : function() {};
                this.resolve = function(func) {
                        let newPromise = new Promise(func);
                        newPromise.status = 'fulfilled';
                        return newPromise;
                }

                this.reject = function(func) {
                        let newPromise = new Promise(func);
                        newPromise.status = 'failed';
                        return newPromise;
                }
            }
            MyPromise.prototype.then = function(resolve, reject) {
                let self = this;
                this.resolve = resolve;
                this.reject = reject;
                let _resolve = function(a) {
                    self.status = 'fulfilled';
                    resolve(a);
                }
                let _reject = function(a) {
                    self.status = 'failed';
                    reject(a);
                }
                if (this.status === 'unfulfilled') 
                        this.fn(_resolve, _reject);
                if (this.status === 'fulfilled') 
                        this.fn(resolve);
                if (this.status === 'failed') 
                        this.fn(reject);
                return this;
            }

            p = function(value) {
                return new MyPromise((resolve, reject) =&gt; {
                    setTimeout(function() {
                        if (value &lt; 10) {
                            resolve(value);
                        }
                        else {
                            reject(value);
                        }
                    }, 1000)
                })
            }
            p(9)
            .then(data =&gt; {
                    console.log('fulfilled = ', data);
                }, data =&gt; {
                    console.log('unfulfilled = ', data);
                })
            .then(data =&gt; {
                    console.log('transfer..');
                    return data + 10;
                })
            .then(data =&gt; {
                    console.log('fulfilled = ', data);
                }, data =&gt; {
                    console.log('unfulfilled = ', data);
                })
            MyPromise.resolve((resolve) =&gt; {
                setTimeout(function() {
                        resolve('i love you');
                }, 1000)
            }).then(data =&gt; {
                    console.log('fulfilled = ', data);
                })
</code></pre>
<h4 id="3-promise看了别人代码后自己写的">3) Promise(看了别人代码后自己写的)</h4>
<blockquote>
<ul>
<li>为了支持同步的Promise，采用异步调用_resolve和_reject</li>
<li>then方法比较复杂，首先返回的是一个promise，然后根据不同的返回值类型进行进一步处理</li>
<li>function(cal) {try {resolve(val) or reject(val)} catch(e) {reject(e)}}</li>
<li>catch是唯一没有可能返回promise的函数</li>
<li>resolve和reject方法就是返回一个仅有resolve或者reject方法的promise，同时resolve方法将判断参数的类型，如果参数是非promise类型，将会把它包装成promise类型</li>
<li>all方法是返回一个promise，循环得到结果放到一个数组中，由于每个子项执行的时间不一致，只能新建计数器来统计then执行的次数，当计数器等于all的数组参数个数的时候才进行resolve的统一处理结果数组</li>
<li>race方法是返回一个promise，遍历所有的promise数组，不需要搜集结果</li>
</ul>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */

            // 定义状态常量
            const PENDDING = 'pendding';
            const FULFILLED = 'fulfilled';
            const UNFULFILLED = 'unfulfilled';

            // 判断是否是函数类型
            let isFunction = function (func) {
                return typeof func === 'function'
            };

            class MyPromise {

                constructor(handle) {

                    // 判断handle是否是函数
                    if (!isFunction(handle)) {
                        throw new Error('Your handle is not function!')
                    }

                    // 定义初始状态
                    this._status = PENDDING;

                    // 定义每次执行函数的参数
                    this._value = undefined;

                    // 定义resolve队列和reject，用于链式调用
                    this._resolveQueue = [];
                    this._rejectQueue = [];

                    // 执行handle;
                    try {
                        handle(this._resolve.bind(this), this._reject.bind(this));
                    }
                    catch(err) {
                        this._reject(err);
                    }
                }

                // 添加resolve时执行的函数
                _resolve(val) {

                    // 判断此时的状态，如果是非PENDDING状态就直接结束
                    if (this._status !== PENDDING) return;

                    let run = function() {
                        // 执行队列
                        let execQueue = function(queue, argu) {
                            let exec;
                            while(exec = queue.shift()) {
                                exec(argu);
                            }
                        }

                        // 判断val是否是MyPromise类型
                        // 如果val是MyPromise类型则执行它
                        // 如果val不是MyPromise类型则
                        if (val instanceof MyPromise) {
                            val.then(value =&gt; {
                                this._value = value;
                                this._status = FULFILLED;
                                execQueue(this._resolveQueue, this._value);
                            }, error =&gt; {
                                this._value = error;
                                this._status = UNFULFILLED;
                                execQueue(this._rejectQueue, this._value);
                            })
                        }
                        else {
                            this._value = val;
                            this._status = FULFILLED;
                            execQueue(this._resolveQueue, this._value);
                        }
                    }

                    // 为了支持同步的Promise，这里采用异步调用
                    setTimeout(run.bind(this), 0);
                }  

                // 添加reject时执行的函数
                // 此时不需要判断参数类型是否是MyPromise类型
                _reject(error) {

                    // 判断此时的状态，如果是非PENDDING状态就直接结束
                    if (this._status !== PENDDING) return;

                    let run = function() {
                        // 执行队列
                        let execQueue = function(queue, argu) {
                            let exec;
                            while(exec = queue.shift()) {
                                exec(argu);
                            }
                        }

                        this._value = error;
                        this._status = UNFULFILLED;
                        execQueue(this._rejectQueue, this._value);
                    }

                    // 异步执行
                    setTimeout(run.bind(this), 0);
                }

                // 添加then方法 用于承上启下
                // 当状态是PENDDING时保存每个状态的方法到相应队列
                // 返回的是一个MyPromise
                then(onFulfilled, onRejected) {
                    // 初始化变量
                    const _value = this._value;
                    const _status = this._status;

                    // onFulfilledNext, onRejectedNext为下一个then中的回调函数
                    return new MyPromise((onFulfilledNext, onRejectedNext) =&gt; {

                        // 封装一个可以执行一系列判断的onFulfilled
                        let fulfilled = function(_value) {
                            try {
                                if(isFunction(onFulfilled)) {  //判断onFulfilled是否是函数
                                    let res = onFulfilled(_value);
                                    if(res instanceof MyPromise) { // 假如res是一个MyPromise类型，则需要等res执行完毕才能跳到下一个状态
                                        res.then(onFulfilledNext, onRejectedNext);
                                    }
                                    else { // 假如res不是一个MyPromise类型，则作为下一个then中回调函数中的参数
                                        onFulfilledNext(res);
                                    }
                                }
                                else { // 如果onFulfilled不是函数
                                    onRejectedNext(_value);
                                }
                            }
                            catch (err) {
                                onRejectedNext(err);
                            }
                        }

                        // 封装一个可以执行一系列判断的onRejected
                        let rejected = function(_value) {
                            try {
                                if(isFunction(onRejected)) { // 如果onRejected是函数
                                    let res = onRejected(_value); 
                                    if(res instanceof MyPromise) { // 假如res是一个MyPromise类型，则需要等res执行完毕才能跳到下一个状态
                                        res.then(onFulfilledNext, onRejectedNext);
                                    }
                                    else {  // 假如res不是一个MyPromise类型，则作为下一个then中回调函数中的参数
                                        onFulfilledNext(res);
                                    }
                                }
                                else { // 如果onRejected不是函数
                                    onRejectedNext(_value);
                                }
                            }
                            catch (err) {
                                onRejectedNext(err);
                            }
                        }

                        // 判断_status的状态才决定执行怎样的处理函数
                        switch (_status) {
                            case PENDDING: // 如果是PENNDING的话把onFulfilled和onRejected保存到队列中
                                this._resolveQueue.push(fulfilled);
                                this._rejectQueue.push(rejected);
                                break
                            case FULFILL: // 如果是FULFILL状态，则马上执行onFulfilled
                                fulfilled(_value);
                                break   
                            case UNFULFILL:  // 如果是UNFULFILL状态，则马上执行onRejected
                                rejected(_value);
                                break
                        }
                    })
                }
                static resolve(val) {
                    return val instanceof MyPromise ? val : new MyPromise((resolve, reject) =&gt; {
                        resolve(val);
                        })
                }
                static reject(err) {
                    return new MyPromise((resolve, reject) =&gt; {
                        reject(err);
                    })
                }

                static catch(rejected) {
                    return this.then(undefined, rejected);
                }

                static all(promiseArr) {
                    let res = [];
                    let num = 0;
                    return new MyPromise((resolve, reject) =&gt; {
                        promiseArr.forEach(item =&gt; {
                            this.resolve(item).then(argu =&gt; {
                                res.push(argu);
                                num++;
                                if (num === promiseArr.length)
                                    resolve(res)
                            }, error =&gt; reject(error))
                        })
                    });
                }

                static race(promiseArr) {
                    return new MyPromise((resolve, reject) =&gt; {
                        promiseArr.forEach(item =&gt; {
                            this.resolve(item).then(res =&gt; resolve(res), err =&gt; reject(err));
                        })
                    })
                }
            }

            p = function(value) {
                return new MyPromise((resolve, reject) =&gt; {
                    setTimeout(function() {
                        if (value &lt; 10) {
                            resolve(value);
                        }
                        else {
                            reject(value);
                        }
                    }, 1000)
                })
            }

            p(9)
            .then(data =&gt; {
                    console.log('fulfilled = ', data);
                    return data;
                }, data =&gt; {
                    console.log('unfulfilled = ', data);
                })
            .then(data =&gt; {
                    console.log('transfer..');
                    return p(data + 10);
                })
            .then(data =&gt; {
                    console.log('fulfilled = ', data);
                }, data =&gt; {
                    console.log('unfulfilled = ', data);
                })

            // 结果
            fulfilled =  9
            VM17445:9 transfer..
            VM17445:15 unfulfilled =  19

            let pTime = function(value, delay) {
                return new MyPromise((resolve, reject) =&gt; {
                    setTimeout(function() {
                        if (value &lt; 10) {
                            resolve(value);
                        }
                        else {
                            reject(value);
                        }
                    }, delay)
                })
            }

            MyPromise.race([pTime(9, 5000), pTime(8, 3000), pTime(7, 1000)]).then(data =&gt; {
                console.log('fulfilled = ', data);
            }, data =&gt; {
                console.log('unfulfilled = ', data);
            }) 

            //fulfilled =  7

            MyPromise.race([pTime(18, 5000), pTime(19, 3000), pTime(20, 1000)]).then(data =&gt; {
                console.log('fulfilled = ', data);
            }, data =&gt; {
                console.log('unfulfilled = ', data);
            })

            // unfulfilled =  20

            MyPromise.all([pTime(7, 5000), pTime(8, 3000), pTime(9, 1000)]).then(data =&gt; {
                console.log('fulfilled = ', data);
            }, data =&gt; {
                console.log('unfulfilled = ', data);
            })

            // fulfilled =  (3) [9, 8, 7]
</code></pre>
<h3 id='3.4'>3.4 观察者模式</h3>
<h4 id="1-要点">1) 要点</h4>
<blockquote>
<ul>
<li>监听器listener：其实是一系列的函数</li>
<li>监听器类型: type</li>
<li>监听器注册表：</li>
</ul>
</blockquote>
<pre><code>            let _registers = [
                                {
                                    type: '',
                                    listener: ''
                                },
                                ...
                            ]
</code></pre>
<blockquote>
<ul>
<li>监听器列表：</li>
</ul>
</blockquote>
<pre><code>            let _listeners = {
                type1: [
                        listener1,
                        listener2,
                        ...
                ],
                type2: [
                        listener1,
                        listener2,
                        ...
                ],
                ...
            }
</code></pre>
<blockquote>
<ul>
<li>建立一个类</li>
</ul>
<blockquote>
<ul>
<li>原型变量:注册表和监听器列表</li>
<li>原型方法：添加/删除 某类型的监听器</li>
</ul>
</blockquote>
</blockquote>
<h4 id="2-代码">2) 代码</h4>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */

            let Listen = function() {

            }
            Listen.prototype = {
                _listeners: {},
                _registers: [],
                addListener: function(type, listener) {
                    this._listeners[type] = this._listeners[type] ? this._listeners[type] : [];
                    this._listeners[type].push(listener);
                },
                removeListener: function(type, listener) {
                    let index = this._listeners[type].indexOf(listener);
                    if (index &gt;= 0) {
                        this._listeners[type].splice(index,index+1);
                    }
                },
                register: function(type, listener) {
                    this._registers.push(
                        {
                            type: type,
                            listener: listener
                        }
                    )
                },
                trigger: function(type, var_args) {
                    let funcs = this._listeners[type];
                    let args = [].slice.call(arguments, 1);
                    return funcs.map(func =&gt; func.apply(this, args));
                }
            }
            Listen.prototype.contructor = Listen;
</code></pre>
<h3 id='3.5'>3.5 防抖动和截流</h3>
<h4 id="1-相同点">1) 相同点</h4>
<blockquote>
<ul>
<li>防止用户频繁的操作造成阻塞或者屏幕抖动，提升用户体验</li>
<li>提升性能</li>
</ul>
</blockquote>
<h4 id="2-不同点">2) 不同点</h4>
<blockquote>
<ul>
<li>防抖动是发生在操作与操作之间的时间空隙，拉长操作之间的延迟时间</li>
<li>截流是指在连续重复的操作中，保证每次的操作时间周期，一般比操作实际运行的时间要长</li>
</ul>
</blockquote>
<h4 id="3-防抖动">3) 防抖动</h4>
<blockquote>
<ul>
<li>需要用到setTimeout</li>
<li>用bounce对回调函数进行包装</li>
<li>注意setTimeout和的作用域：内部延迟执行的代码中的this永远指向window，但是回调函数本身的this可以指向其他，所以setTimeout需要先在全局进行定义。</li>
</ul>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */
            let myTimer;
            let deBounce = function(delayTime, callback) {
                clearTimeout(myTimer);
                myTimer = setTimeout(function() {
                        if(callback) callback()
                        console.log('用户的操作。。。');
                    }, delayTime);
            }

            document.addEventListener('click', function() {
                deBounce(3000);
            });
</code></pre>
<h4 id="4-截流频率控制">4) 截流/频率控制</h4>
<blockquote>
<ul>
<li>需要比较实际运行时间长度和设定的周期时间</li>
<li>立即执行，无需使用setTimeout</li>
<li>如果实际运行时间长度 &gt; 设定的周期时间, 则运行回调，并且把当前时间戳设为旧时间戳；</li>
</ul>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */

            let old = new Date();
            let throttle = function(cycleTime, callback) {
                let now = new Date();
                if (now - old &gt; cycleTime) {
                    if (callback) callback();
                    old = now;
                }
            }

            document.addEventListener('click', function() {
                throttle(3000, function() {
                        console.log('i am working');
                    });
            });
</code></pre>
<h4 id="5-防抖动和截流合并">5) 防抖动和截流合并</h4>
<blockquote>
<ul>
<li>在截流里面把防抖动的函数写进去</li>
</ul>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */

            let old = new Date();
            let myTimer;
            let bounceAndThrottle = function(cycleTime, delayTime, callback) {
                let now = new Date();
                if (now - old &gt; cycleTime) {
                    console.log('Flow。。。');
                    clearTimeout(myTimer);
                    myTimer = setTimeout(function() {
                            if(callback) callback()
                        }, delayTime);
                    old = now;
                }
            }

            document.addEventListener('click', function() {
                debounceAndThrottle(3000, 5000, function() {
                        console.log('i am working');
                    });
            });
</code></pre>
<h3 id='3.6'>3.6 类的继承</h3>
<h4 id="1-属性拷贝">1) 属性拷贝</h4>
<blockquote>
<ul>
<li>这是最简单的，把父类的属性全都拷贝一份</li>
</ul>
</blockquote>
<h4 id="2-原型式继承">2) 原型式继承</h4>
<blockquote>
<ul>
<li>只能继承父构造函数的原型对象上的成员, 不能继承父构造函数的实例对象的成员</li>
</ul>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */

            // 父类
            function Parent(age) {
                this.age = age;
                this.friends = ['a', 'b'];
            }
            Parent.prototype.name = ['lvweiyaun'];
            Parent.prototype.tellName = function() {
                console.log(this.name);
            }

            // 子类
            function Child(sex) {
                this.sex = sex;
            }
            Child.prototype = Parent.prototype;
            Child.prototype.constructor = Child;
            let child1 = new Child('male');
            console.log('child1.name = ', child1.name);
            console.log('child1.friends = ', child1.friends);

            // child1.name =  [&quot;lvweiyaun&quot;]
            // undefined
</code></pre>
<h4 id="3-原型链继承">3) 原型链继承</h4>
<blockquote>
<ul>
<li>将父类的公有和私有属性和公有方法都继承过来的</li>
<li>优点：直接把父类的原型（浅）拷贝过来，简单易用</li>
<li>缺点</li>
</ul>
<blockquote>
<ul>
<li>新实例无法向父类构造函数传参</li>
<li>存在父类私有引用类型属性共享的问题</li>
</ul>
</blockquote>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */

            // 父类
            function Parent(age) {
                this.age = age;
                this.friends = ['a', 'b'];
            }
            Parent.prototype.name = ['lvweiyaun'];
            Parent.prototype.tellName = function() {
                console.log(this.name);
            }

            // 子类
            function Child(sex) {
                this.sex = sex;
            }
            Child.prototype = new Parent(50);
            Child.prototype.constructor = Child;
            let child1 = new Child('male');
            console.log('child1.friends = ', child1.friends);
            let child2 = new Child('female');
            console.log('child2.friends = ', child2.friends);
            child2.friends.push('lvhongbin');
            console.log('child2.friends = ', child2.friends);
            console.log('child1.friends = ', child1.friends);

            // child1.friends =  [&quot;a&quot;, &quot;b&quot;]
            // child2.friends =  [&quot;a&quot;, &quot;b&quot;]
            // child2.friends =  [&quot;a&quot;, &quot;b&quot;, &quot;lvhongbin&quot;]
            // child1.friends =  [&quot;a&quot;, &quot;b&quot;, &quot;lvhongbin&quot;]
</code></pre>
<h4 id="4-构造函数继承">4) 构造函数继承</h4>
<blockquote>
<ul>
<li>使用call继承父类的构造函数</li>
<li>好处：可以得到父类的构造函数属性，向父类构造函数传参。</li>
<li>坏处：无法得到父类的原型属性</li>
</ul>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */
            // 父类
            function Parent(age) {
                this.age = age;
            }
            Parent.prototype.name = ['lvweiyaun'];
            Parent.prototype.tellName = function() {
                console.log(this.name);
            }

            // 子类
            function Child(sex, age) {
                Parent.call(this, age);
                this.sex = sex;
            }
            let child1 = new Child('male', 20);
            console.log('child1.name = ', child1.name);
            let child2 = new Child('female', 22);
            console.log('child2.name = ', child2.name);
            child2.name.push('lvhongbin');
            console.log('child2.name = ', child2.name);
            let p = new Parent(55);
            console.log('p.name = ', p.name);
            console.log('child1.name = ', child1.name);
            console.log('child1.age = ', child1.age);


            // child1.name =  undefined
            // child2.name =  undefined
            // error!
            p.name =  [&quot;lvweiyaun&quot;]
            // child1.name =  undefined
            child1.age =  20
</code></pre>
<h4 id="5-组合继承">5) 组合继承</h4>
<blockquote>
<ul>
<li>原型链继承 + 构造函数继承</li>
<li>解决了对象共享的问题，还能拿到父类的构造函数</li>
<li>但是存在性能问题，因为父类有两次构造</li>
</ul>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */
            // 父类
            function Parent(age) {
                this.age = age;
                this.friends = ['a', 'b'];
            }

            Parent.prototype.name = ['lvweiyaun'];
            Parent.prototype.tellName = function() {
                console.log(this.name);
            }

            // 子类
            function Child(sex, age) {
                Parent.call(this, age);
                this.sex = sex;
            }
            Child.prototype = new Parent(50);
            Child.prototype.constructor = Child;
            let child1 = new Child('male', 20);
            console.log('child1.name = ', child1.name);
            console.log('child1.friends = ', child1.friends);
            let p = new Parent(55);
            console.log('p.name = ', p.name);
            console.log('child1.name = ', child1.name);
            console.log('child1.age = ', child1.age);


            // child1.name =  [&quot;lvweiyaun&quot;]
            // child1.friends =  [&quot;a&quot;, &quot;b&quot;]
            // p.name =  [&quot;lvweiyaun&quot;]
            // child1.name =  [&quot;lvweiyaun&quot;]
            // child1.age =  20
</code></pre>
<h4 id="6-组合继承优化1">6) 组合继承优化1</h4>
<blockquote>
<ul>
<li>原型式继承 + 构造函数继承</li>
<li>解决了对象共享的问题，还能拿到父类的构造函数</li>
<li>不存在性能问题</li>
<li>但是子类无法修改原型的constructor属性，因为一旦修改就会同时修改父类的constructor属性，换句话说无法辨别子类的构造函数是谁</li>
</ul>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */
            // 父类
            function Parent(age) {
                this.age = age;
                this.friends = ['a', 'b'];
            }
            Parent.prototype.name = ['lvweiyaun'];
            Parent.prototype.tellName = function() {
                console.log(this.name);
            }

            // 子类
            function Child(sex, age) {
                Parent.call(this, age);
                this.sex = sex;
            }
            Child.prototype = Parent.prototype;
            Child.prototype.constructor = Child;
            
            let child1 = new Child('male', 20);
            console.log('child1.name = ', child1.name);
            console.log('child1.friends = ', child1.friends);
            let p = new Parent(55);
            console.log('p.name = ', p.name);
            console.log('child1.name = ', child1.name);
            console.log('child1.age = ', child1.age);
            p instanceof Child;


            // child1.name =  [&quot;lvweiyaun&quot;]
            // child1.friends =  [&quot;a&quot;, &quot;b&quot;]
            // p.name =  [&quot;lvweiyaun&quot;]
            // child1.name =  [&quot;lvweiyaun&quot;]
            // child1.age =  20
            // true
</code></pre>
<h4 id="7-组合继承优化2">7) 组合继承优化2</h4>
<blockquote>
<ul>
<li>目前来讲比较完美的方法</li>
<li>使用寄生式组合继承</li>
</ul>
</blockquote>
<pre><code>            // 父类
            function Parent(age) {
                this.age = age;
                this.friends = ['a', 'b'];
            }
            Parent.prototype.name = ['lvweiyaun'];
            Parent.prototype.tellName = function() {
                console.log(this.name);
            }

            // 子类
            function Child(sex, age) {
                Parent.call(this, age);
                this.sex = sex;
            }
            Child.prototype = Object.create(Parent.prototype);
            Child.prototype.constructor = Child;

            let child1 = new Child('male', 20);
            console.log('child1.name = ', child1.name);
            console.log('child1.friends = ', child1.friends);
            let p = new Parent(55);
            console.log('p.name = ', p.name);
            console.log('child1.name = ', child1.name);
            console.log('child1.age = ', child1.age);
            p instanceof Child;

            // child1.name =  [&quot;lvweiyaun&quot;]
            // child1.friends =  [&quot;a&quot;, &quot;b&quot;]
            // p.name =  [&quot;lvweiyaun&quot;]
            // child1.name =  [&quot;lvweiyaun&quot;]
            // child1.age =  20
            // false
</code></pre>
<h3 id='3.7'>3.7 new</h3>
<h4 id="1-要点-1">1) 要点</h4>
<blockquote>
<ul>
<li>返回一个对象</li>
<li>对象的原型属性等于函数的原型</li>
<li>对象的属性需要函数去更换自身的作用域为对象的作用域获得</li>
</ul>
</blockquote>
<pre><code>            Function.prototype.myNew = function() {
                let obj = {};
                obj.__proto__ = this.prototype;
                let argu = [].slice.call(arguments);
                this.call(obj, ...argu);
                return obj;
            }

            function a(num1, num2) {
                this.num1 = num1;
                this.num2 = num2;
            }
            a.prototype.tell = function() {
                console.log(this.num1 + this.num2);
            }

            let b = a.myNew(1,2);
            b.tell(); // 3

            let c = new a(1,2);
</code></pre>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p><img src="https://github.com/hblvsjtu/FET/blob/master/picture/%E5%9B%BE3-1%20new%E5%8E%9F%E7%90%86.png?raw=true" alt="图3-1 new原理"></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h3 id='3.8'>3.8 Object.create()</h3>
<h4 id="1-参数">1) 参数</h4>
<blockquote>
<ul>
<li>第一个参数是原型对象</li>
<li>第二个参数是属性特性：value, writable, enumberable, congigurable</li>
</ul>
</blockquote>
<pre><code>            Object.prototype.myCreate = function(proto, properties) {
                let f = function() {};
                f.prototype = proto;
                let o = new f();
                if (typeof properties === 'object') {
                    Object.defineProperties(o, properties);
                }
                return o;
            }
</code></pre>
<h3 id='3.9'>3.9 Object.keys/Object.values/Object.entries</h3>
<h4 id="1-objectkeys">1) Object.keys</h4>
<blockquote>
<ul>
<li>返回对象的每个可枚举的自身属性键名组成的数组</li>
</ul>
</blockquote>
<pre><code>            Object.prototype.myKeys = function(o) {
                let arr = []
                for(let key in o) {
                    if(o.hasOwnProperty(key)) arr.push(key);
                }
                return arr;
            }
</code></pre>
<h4 id="2-objectvalues">2) Object.values</h4>
<blockquote>
<ul>
<li>返回对象的每个可枚举的自身属性键值组成的数组</li>
</ul>
</blockquote>
<pre><code>            Object.prototype.myValues = function(o) {
                let arr = []
                for(let key in o) {
                    if(o.hasOwnProperty(key)) arr.push(o[key]);
                }
                return arr;
            }
</code></pre>
<h4 id="2-objectentrie">2) Object.entrie</h4>
<blockquote>
<ul>
<li>返回对象的每个可枚举的自身属性键名和键值组成的数组
Object.prototype.myEntries = function(o) {
let arr = []
for(let key in o) {
if(o.hasOwnProperty(key)) arr.push([key, o[key]]);
}
return arr;
}</li>
</ul>
</blockquote>
<h3 id='3.10'>3.10 setTimeout 与 setInterval</h3>
<h4 id="1-最短间隔时间">1) 最短间隔时间</h4>
<blockquote>
<ul>
<li>如果回调时间大于间隔时间，浏览器才会执行，这也导致了真正的间隔时间比原来的大一点</li>
<li>这个最短间隔时间该怎么测呢？可以利用在定时器内再嵌一个定时器</li>
</ul>
</blockquote>
<pre><code>            let timeList = [];
            let f = function(total, delay) {
                let sum = 0;
                let c = 0;
                let id = setTimeout(function() {
                    c++;
                    timeList.push(new Date());
                    if(c &gt; total) {
                        clearTimeout(id);
                        for(let i = 0; i &lt; total - 1; i++) {
                            sum += timeList[i+1] - timeList[i];
                        }
                        console.log('the shortest delayTime is ', sum/(total - 1))
                    }
                    else setTimeout(arguments.callee, delay);
                }, delay);
            }
            f(100, 1); // the shortest delayTime is 4.878787878787879 in chrome
            f(1000, 1); // the shortest delayTime is  83.83883883883884 in chrome
</code></pre>
<h3 id='3.11'>3.11 跨域</h3>
<h4 id="1-通过documentdomain跨域">1) 通过document.domain跨域</h4>
<blockquote>
<ul>
<li>在相同的域名下建立文件</li>
</ul>
</blockquote>
<h4 id="2-通过locationhash跨域">2) 通过location.hash跨域</h4>
<blockquote>
<ul>
<li>但是如果内嵌的页面不同源的话是无法拿到iframe的document的</li>
</ul>
</blockquote>
<pre><code>            let src = 'https://www.baidu.com';
            let msg = 'helloB'
            function createIframe(src) {    
                let frag = document.createDocumentFragment();
                let ifm = document.createElement('iframe');
                ifm.src = src;
                ifm.style.display = 'none';
                frag.appendChild(ifm);
                document.body.appendChild(frag);
            }

            function checkHash() {
                return location.hash ? location.hash.slice(1) : '';
            }
            window.addEventListener(&quot;hashchange&quot;, function() {
                console.log('hash has been changed, now hash is', checkHash());
            }, false);

            createIframe(src + '#' + msg);

            let i = document.getElementsByTagName('iframe')[ document.getElementsByTagName('iframe').length - 1];
            let ifmScript = document.createElement('script');
            ifmScript.innerHTML = &quot;&quot;
                +  &quot;let hash = location.hash ? location.hash.slice(1) : '';\n&quot;
                +  &quot;let message = hash + 'helloA';\n&quot;
                +  &quot;try {\n&quot;
                +  &quot;  parent.location.hash = message;\n&quot;
                +  &quot;  console.log('OK, i am done, message = ', message);\n&quot;
                +  &quot;} catch (e) {\n&quot;
                +  &quot;  // ie、chrome的安全机制无法修改parent.location.hash，\n&quot;
                +  &quot;  // 所以要利用一个中间的cnblogs域下的代理iframe\n&quot;
                +  &quot;  var ifrproxy = document.createElement('iframe');\n&quot;
                +  &quot;  ifrproxy.style.display = 'none';\n&quot;
                +  &quot;  ifrproxy.src = 'http://ecma.bdimg.com/adtest/limukai/demo/test/cscript/cs3.html#' + message;  \n&quot;
                +  &quot;  // 注意该文件在a.com域下\n&quot;
                +  &quot;  document.body.appendChild(ifrproxy);\n&quot;
                +  &quot;  let i = document.getElementsByTagName('iframe')[ document.getElementsByTagName('iframe').length - 1];\n&quot;
                +  &quot;  let ifmScript = document.createElement('script');\n&quot;
                +  &quot;  ifmScript.innerHTML = 'parent.parent.location.hash = self.location.hash.substring(1);'\n&quot;
                +  &quot;  ifrproxy.appendChild(ifmScript);\n&quot;
                + &quot;}&quot;
            i.contentWindow.document.body.appendChild(ifmScript);
</code></pre>
<h4 id="3-通过postmessage">3) 通过postMessage</h4>
<blockquote>
<ul>
<li>好像也做不了</li>
<li>需要判断源origin，否则容易收到XXR攻击</li>
</ul>
</blockquote>
<pre><code>            let msgHandler = function(event) {
                console.log('event.data', event.data);
            }
            window.addEventListener('message', msgHandler, false);

            let src = 'https://www.baidu.com';
            let msg = 'helloB'
            function createIframe(src) {    
                let frag = document.createDocumentFragment();
                let ifm = document.createElement('iframe');
                ifm.src = src;
                ifm.style.display = 'none';
                frag.appendChild(ifm);
                document.body.appendChild(frag);
            }
            createIframe(src + '#' + msg);

            let i = document.getElementsByTagName('iframe')[ document.getElementsByTagName('iframe').length - 1];
            let iframe = i.contentWindow;
            iframe.postMessage('hello world', 'https://segmentfault.com/a/1190000012264815');
</code></pre>
<h4 id="4-jsonp">4) Jsonp</h4>
<blockquote>
<ul>
<li>只支持GET，不支持POST请求</li>
<li>它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</li>
<li>支持老版本的浏览器</li>
</ul>
</blockquote>
<pre><code>        // 自己的页面
        &lt;script&gt;
            function exec(data) {
                console.log(data);
            }
        &lt;/script&gt;
        &lt;script src=&quot;http://www.baidu.com?callback=exec&quot;&gt;&lt;/script&gt;

        // 后端
            1，判断callback的名称；
            2，处理数据data
            3，返回js文件里面写着： exec(data);
</code></pre>
<h4 id="5-access-control-allow-origin">5) Access-Control-Allow-Origin</h4>
<blockquote>
<ul>
<li>存在兼容性的问题，不兼容老版本的浏览器</li>
<li>服务器设置</li>
</ul>
</blockquote>
<pre><code>            //指定允许其他域名访问
            'Access-Control-Allow-Origin:http://172.20.0.206'//一般用法（*，指定域，动态设置，但不允许携带认证头和cookies
            //是否允许后续请求携带认证信息（cookies）,该值只能是true,否则不返回
            'Access-Control-Allow-Credentials:true'
            //预检结果缓存时间
            'Access-Control-Max-Age: 1800'
            //允许的请求类型
            'Access-Control-Allow-Methods:GET,POST,PUT,POST'
            //允许的请求头字段
            'Access-Control-Allow-Headers:x-requested-with,content-type'
</code></pre>
<h3 id='3.12'>3.12 函数柯里化</h3>
<h4 id="1-定义">1) 定义</h4>
<blockquote>
<ul>
<li>一个函数接受一些参数后返回一个新的函数，这个新的函数继续接收剩余的参数</li>
<li>比如：</li>
</ul>
</blockquote>
<pre><code>            // 原函数
            function origin(a, b, c) {

            }

            // 柯里化
            function curry(a) {
                return function(b, c) {

                }
            }
</code></pre>
<h4 id="2-两段不定参数版本">2) 两段不定参数版本</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */
            function curry() {
                let args1 = [].slice.call(arguments);
                return function() {
                    let args2 = [].slice.call(arguments);
                    argus = args1.concat(args2);
                    console.log(argus);
                }
            }
            curry(1)(2); //[1, 2]
            curry(1,2)(2,3,4); //  [1, 2, 2, 3, 4]
</code></pre>
<h4 id="3-不定段不定参数版本">3) 不定段不定参数版本</h4>
<blockquote>
<ul>
<li>无限累加器</li>
<li>points</li>
</ul>
<blockquote>
<ul>
<li>改写函数的toSting()和valueOf()方法</li>
<li>返回的函数作为参数收集器</li>
<li>真正做处理方法是toSting()和valueOf()方法</li>
</ul>
</blockquote>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */
            function curry() {

                let args = [].slice.call(arguments);

                let _curry = function() { 
                    let add = function() {
                        args.push(...arguments) // 为了搜集参数
                        return add;
                    }

                    add.toString = function() { // 输出结果
                        return args.reduce((total, item) =&gt; {
                            return total + item;
                        })
                    }
                    return add;
                }

                return _curry(...args);
            }
</code></pre>
<h3 id='3.13'>3.13 高阶函数</h3>
<h4 id="1-定义-1">1) 定义</h4>
<blockquote>
<ul>
<li>接受一个或多个函数作为输入</li>
<li>输出一个函数</li>
</ul>
</blockquote>
<h4 id="2-实现一个map函数">2) 实现一个map函数</h4>
<blockquote>
<ul>
<li>挂靠在Array数组原型上</li>
</ul>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */
            Array.prototype.myMap = function(func) {
                let l = this.length;
                let temp = [];
                for(let i = 0; i &lt; l; i++) {
                    temp[i] = func(this[i], i, this);
                }
                return temp;
            }
</code></pre>
<h4 id="3-实现一个foreach函数">3) 实现一个forEach函数</h4>
<blockquote>
<ul>
<li>挂靠在Array数组原型上</li>
</ul>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */
            Array.prototype.myForEach = function(func) {
                let l = this.length;
                for(let i = 0; i &lt; l; i++) {
                    func(this[i], i, this);
                }
            }
</code></pre>
<h4 id="4-实现一个reduce函数">4) 实现一个reduce函数</h4>
<blockquote>
<ul>
<li>挂靠在Array数组原型上</li>
</ul>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */
            Array.prototype.myReduce = function(func, init) {
                let l = this.length;
                let result = init ? init : 0;
                for(let i = 0; i &lt; l; i++) {
                    result = func(result, this[i], init);
                }
                return result;
            }
</code></pre>
<h4 id="5-实现一个filter函数">5) 实现一个filter函数</h4>
<blockquote>
<ul>
<li>挂靠在Array数组原型上</li>
</ul>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */
            Array.prototype.myFilter = function(func) {
                let l = this.length;
                let arr = [];
                while(l--) if(func(this[l])) arr.unshift(this[l]);
                return arr;
            }
</code></pre>
<hr>
<h2 id='4'>四、正则表达式</h2>
<h3 id='4.1'>4.1 断言</h3>
<h4 id="1-定义-2">1) 定义</h4>
<blockquote>
<ul>
<li>断言前面或者后面有规定的字符串，但断言的字符串并不计入输出</li>
</ul>
</blockquote>
<h4 id="2-类型">2) 类型</h4>
<blockquote>
<ul>
<li>向前断言 (?&lt;=) (?&lt;!)</li>
<li>向后断言 (?=) (?!)</li>
</ul>
</blockquote>
<h3 id='4.2'>4.2 反向引用</h3>
<h4 id="1-定义-3">1) 定义</h4>
<blockquote>
<ul>
<li>\数字 表示前面匹配到的第n个分组,改分组必须与前面的分组字面上一模一样</li>
</ul>
</blockquote>
<pre><code>            '168.132.132.132'.match(/(?:\d{1,3})(\.\d{1,3})\1{2}/);
            // [&quot;168.132.132.132&quot;, &quot;.132&quot;, index: 0, input: &quot;168.132.132.132&quot;, groups: undefined]
</code></pre>
<h4 id="2-要点">2) 要点</h4>
<blockquote>
<ul>
<li>非获取匹配分组 (?:)，用来忽视某个分组的</li>
</ul>
</blockquote>
<pre><code>            '168.131.31.1'.match(/(?:\d{1,3})(\d{1,3}\.)\1{2}/)
</code></pre>
<h3 id='4.3'>4.3 非贪婪</h3>
<h4 id="1-定义-4">1) 定义</h4>
<blockquote>
<ul>
<li>用在{1，2}，+,*等后面，匹配最小的那个数量</li>
</ul>
</blockquote>
<h3 id='4.4'>4.4 电话号码/身份证/网址/邮箱</h3>
<h4 id="1-qq号码">1) QQ号码</h4>
<blockquote>
<ul>
<li>对QQ号码进行校验要求5~11位,不能以0开头,只能是数字</li>
</ul>
</blockquote>
<pre><code>            /^[1-9]\d{4,10}$/.test('2606138901'); // true
            /^[1-9]\d{4,10}$/.test('0606138901'); // false
</code></pre>
<h4 id="2-电话号码">2) 电话号码</h4>
<blockquote>
<ul>
<li>纯数字第一位必须是1开头第二位必须是3、4、5、7、8,第三位~第十一只要是数字即可</li>
</ul>
</blockquote>
<pre><code>            /^1[34578]\d{9}$/.test('18028543872'); // true
            /^1[34578]\d{9}$/.test('12028543872'); // false
</code></pre>
<h4 id="3-身份证">3) 身份证</h4>
<blockquote>
<ul>
<li>身份证号码为15位或者18位，15位时全为数字，18位前17位为数字，最后一位是校验位，可能为数字或者X或者x</li>
</ul>
</blockquote>
<pre><code>            /(^\d{15}$)|(^\d{17}[\dxX]$)/.test('440782199309241618'); // true
            /(^\d{15}$)|(^\d{17}[\dxX]$)/.test('44078219930924161X'); // true
            /(^\d{15}$)|(^\d{17}[\dxX]$)/.test('44078219930924161s'); // false
</code></pre>
<h4 id="3-网址">3) 网址</h4>
<blockquote>
<ul>
<li>DNS规定，域名中的标号都由英文字母和数字组成，每一个标号不超过63个字符，也不区分大小写字母。标号中除连字符（-）外不能使用其他的标点符号。级别最低的域名写在最左边，而级别最高的域名写在最右边。由多个标号组成的完整域名总共不超过255个字符。</li>
</ul>
</blockquote>
<pre><code>            /^[hH][tT]{2}[pP][sS]?:\/\/(www\.)?([\w\d-~]{1,63}\.)+([\w\d-~\/])+$/.test('https://www.baidu.com'); //true
</code></pre>
<h4 id="4-邮箱">4) 邮箱</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<pre><code>            /^[a-zA-Z0-9]+@[a-zA-Z0-9]{1,5}\.[a-zA-Z0-9]{1,5}$/.test('supersteelsoul@163.com'); // true
</code></pre>
<hr>
<h2 id='6'>五、js和html效果篇</h2>
<h3 id='6.1'>5.1 获取元素样式/位置/尺寸</h3>
<h4 id="1-样式">1) 样式</h4>
<blockquote>
<ul>
<li>element.getAttribute()方法 只能获取内联样式的内容</li>
</ul>
</blockquote>
<pre><code>            var btn=element.getAttribute('style');
</code></pre>
<blockquote>
<ul>
<li>document.styleSheets 获取内嵌样式表或外联样式表，返回值是一个数组</li>
</ul>
</blockquote>
<pre><code>            var styleSheetList = document.styleSheets;
            var styleSheet = styleSheetList[0];
            var cssRuleList = styleSheet.rules;
            var cssStyleRule = cssRuleList[0];
            var styleDecl = cssStyleRule.style;
            console.log(styleDecl.width);
</code></pre>
<blockquote>
<ul>
<li>class属性的操作</li>
</ul>
<blockquote>
<ul>
<li>className</li>
<li>classList 兼容性问题。如果该类名不存在则会在元素中添加类名，并返回 true。 第二个是可选参数，是个布尔值用于设置元素是否强制添加或移除类，不管该类名是否存在.注意： Internet Explorer 或 Opera 12 及其更早版本不支持第二个参数。</li>
</ul>
</blockquote>
</blockquote>
<pre><code>            //元素名.className 需要操作字符串,每个类中间用空格隔开
            var className = ele.className;
            className.replace('classNameA', '').replace(/\s+/g, ' ');
            className.concat(' classNameB').replace(/\s+/g, ' ');
            
            //classList属性(浏览器兼容问题)：获取多个类选择器叠加的用法
            //元素名.classList
            var classList = ele.classList;
            classList.add('className');
            classList.remove('className');
            classList.contains(class)
            classList.toggle(class, true|false) // 第一个参数为要在元素中移除的类名，并返回 false。
</code></pre>
<blockquote>
<blockquote>
<ul>
<li>自定义类解决兼容性问题，可以兼容IE7</li>
</ul>
</blockquote>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */
            Object.prototype.myClassList = function() {
                var self = this;
                return {
                    list: self.className,
                    add: function(className) {
                        self.className = self.className.concat(' ' + className);
                    },
                    remove: function(className) {
                        self.className = self.className.replace(className, '');
                    },
                    contains: function(className) {
                        return self.className.split(/\s+/g).indexOf(className) &gt; -1;
                    },
                    toggle: function(className) {
                        if(self.myClassList().contains(className)) {
                            self.myClassList().remove(className);
                        }
                        else {
                            self.myClassList().add(className);
                        }
                    }
                }
            }

            //
            &gt; div.listClass().list;
            &lt; &quot;s_tab&quot;
            &gt; div.listClass().add('asd');
            &lt; undefined
            &gt; div.listClass().list;
            &lt; &quot;s_tab asd&quot;
            &gt; div.listClass().remove('asd');
            &lt; undefined
            &gt; div.listClass().list;
            &lt; &quot;s_tab &quot;
            &gt; div.listClass().contains('asd');
            &lt; false
            &gt; div.listClass().contains('s_tab');
            &lt; true
            &gt; div.listClass().contains('s_ta');
            &lt; false
            &gt; div.listClass().toggle('s_ta');
            &lt; undefined
            &gt; div.listClass().contains('s_ta');
            &lt; true
            &gt; div.listClass().list;
            &lt; &quot;s_tab  s_ta&quot; 
</code></pre>
<blockquote>
<ul>
<li>获取实时计算的样式 getComputedStyle</li>
</ul>
<blockquote>
<ul>
<li>只读的，不能写。</li>
<li>获取的是最终应用在元素上的所有CSS属性对象</li>
<li>currentStyle不能读取伪类，但是getComputedStyle可以</li>
<li>currentStyle是IE自娱自乐的玩意</li>
<li>在访问例如background-color类似格式的css属性时</li>
</ul>
</blockquote>
</blockquote>
<pre><code>            window.getComputedStyle(ele,null).background-color //就不可以了，需要使用
            window.getComputedStyle(ele,null).backgroundColor //可以
            window.getComputedStyle(ele,null).getPropertyValue(“background-color”) // 可以
            
            var style = window.getComputedStyle(&quot;元素&quot;, &quot;伪类&quot;);
            ele.currentStyle[attr]

            // 兼容性写法 如果遇到text的时候会报错，这里return null可以吃掉报错
            /**
              * 
              * @authors ${冰红茶} (${hblvsjtu@163.com})
              * @date    2019-08-01
              * @version $Id$
              */

            Object.prototype.getMyStyle = function(attr, pseudoElt) {
                let style = '';
                try {
                    if(this.currentStyle) {
                        style = this.currentStyle[attr];
                    }
                    else {
                        style = window.getComputedStyle(this, pseudoElt)[attr];
                    }
                }
                catch (e) {
                    return null;
                }
                return style;
            }

            // ie7可能会返回auto值而不是实际的值
</code></pre>
<h4 id="2-位置">2) 位置</h4>
<blockquote>
<ul>
<li>元素的位置</li>
</ul>
<blockquote>
<ul>
<li>getClientRects 返回一个数组，但是该数组只有一个元素，而且是一个对象元素</li>
<li>getBoundingClientRect用于获取元素相对与浏览器视口的位置，它是一个对象</li>
<li>getClientRects和getClientRects都是元素边内界边缘相对于浏览器视口的距离</li>
<li>想要获取元素边内界边缘相对于文档顶部的距离，需要用到offsetTop,offsetLeft和offsetParent</li>
</ul>
</blockquote>
</blockquote>
<pre><code>            getBoundingClientRect： {
                    top: '元素顶部相对于视口顶部的距离',
                    bottom: '元素底部相对于视口顶部的距离',
                    left: '元素左边相对于视口左边的距离',
                    right: '元素右边相对于视口左边的距离',
                    height: '元素高度',
                    width: '元素宽度'
                    x: 8,
                    y: 8,
                }
</code></pre>
<blockquote>
<blockquote>
<ul>
<li>兼容性写法 因为IE没有height和width</li>
</ul>
</blockquote>
</blockquote>
<pre><code>            // 兼容写法
             /**
              * 
              * @authors ${冰红茶} (${hblvsjtu@163.com})
              * @date    2019-08-01
              * @version $Id$
              */

              Object.prototype.getMyRect = function (isToHtml) {
                 var o = this.getBoundingClientRect();
                 var self = this;
                 var offset = function(ele) {
                    var parent = ele.offsetParent;
                    return {
                        top: isToHtml &amp;&amp; parent.offsetParent? ele.offsetTop + offset(parent).top :  ele.offsetTop, 
                        left: isToHtml &amp;&amp; parent.offsetParent ? ele.offsetLeft + offset(parent).left :  ele.offsetLeft
                    }
                 }
                 return {
                     viewTop: o.top, // 获取元素内边距边缘离视窗的距离
                     viewBottom: o.bottom, // 获取元素内边距边缘离视窗的距离
                     viewLeft: o.left, // 获取元素内边距边缘离视窗的距离
                     viewRight: o.right, // 获取元素内边距边缘离视窗的距离
                     height: o.height || o.bottom - o.top, // 获取元素上下内边缘高度，不包括边距
                     width: o.width || o.right - o.left, // 获取元素上下内边缘宽度，不包括边距
                        offsetTop: offset(self).top, //获取元素内边缘距离定位父元素的距离
                        offsetLeft: offset(self).left //获取元素内边缘距离定位父元素的距离
                 }
             }
</code></pre>
<blockquote>
<blockquote>
<ul>
<li>一个例子</li>
</ul>
</blockquote>
</blockquote>
<pre><code>            // main.html
            &lt;div class=&quot;contain&quot;&gt;
                &lt;div class=&quot;camera&quot;&gt;
                    &lt;div class=&quot;cube&quot;&gt;&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            // main.css
            @charset &quot;UTF-8&quot;;
            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-07-31
             * @version $0.0.1$
             */

            .contain {
                position: relative;
                top: 100px;
                left: 100px;
                height: 500px;
                width: 500px;
                overflow: scroll;
                background: yellow;
            }

             .camera {
                position: absolute;
                top: 400px;
                left: 400px;
                width: 200px;
                height: 200px;
                background: red;
             }
             .camera .cube {
                width: 100px;
                height: 100px;
                margin: 50px;
                background: green;
             }

             let contain = document.getElementsByClassName('contain')[0];
             let camera = document.getElementsByClassName('camera')[0];
             let cube = document.getElementsByClassName('cube')[0];
             let camera = document.getElementsByClassName('camera')[0];
</code></pre>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p><img src="https://github.com/hblvsjtu/FET/blob/master/picture/%E5%9B%BE5-1%20%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AEa.png?raw=true" alt="图5-1 元素位置a">
<img src="https://github.com/hblvsjtu/FET/blob/master/picture/%E5%9B%BE5-1%20%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AEb.png?raw=true" alt="图5-1 元素位置b">
<img src="https://github.com/hblvsjtu/FET/blob/master/picture/%E5%9B%BE5-1%20%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AEc.png?raw=true" alt="图5-1 元素位置c">
<img src="https://github.com/hblvsjtu/FET/blob/master/picture/%E5%9B%BE5-1%20%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AEd.png?raw=true" alt="图5-1 元素位置d"></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<ul>
<li>滚动条滚动的距离</li>
</ul>
<blockquote>
<ul>
<li>所有主流浏览器都支持 pageXOffset 和 pageYOffset 属性。注意： IE 8 及 更早 IE版本不支持该属性,但可以使用&quot;document.body.scrollLeft&quot; 和 &quot;document.body.scrollTop&quot; 属性 。</li>
<li>chrome可以使用document.documentElement.scrollLeft和document.documentElement.scrollTop,或者window.pageXoffset与window.pageYoffset。</li>
<li>不管怎样，document.documentElement.scrollTop和document.body.scrollTop只有一个有效，另外一个为0，我们可以利用这一个特点写兼容性</li>
<li>chrome里面的document.body.scrollHeight和document.body.scrollWidth偏小，而document.documentElement.scrollHeight和document.documentElement.scrollWidth正常，且IE也能用，所以就使用document.documentElement.scrollHeight和document.documentElement.scrollWidth吧</li>
</ul>
</blockquote>
<ul>
<li>视窗高度和宽度</li>
</ul>
<blockquote>
<ul>
<li>视窗高度window.innerHeight</li>
<li>视窗宽度window.innerWidth</li>
</ul>
</blockquote>
<ul>
<li>元素内边距边缘距离文档顶部的距离</li>
</ul>
<blockquote>
<ul>
<li>offsetTop 和 offsetLeft 都是相对于其内边距边界的。</li>
<li>HTMLElement.offsetParent 是一个只读属性，返回一个指向最近的定位父元素。如果没有定位的元素，则指向最近的 table 元素或根元素（标准模式下为 html；quirks 模式下为 body）。当元素的 style.display 设置为 &quot;none&quot; 时，offsetParent 返回 null。</li>
</ul>
</blockquote>
</blockquote>
<pre><code>            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-08-01
             * @version $Id$
             */
            // 兼容性写法
            window.getWindowSize = function (doc) {
                let myDocument = doc || document;
                return {
                    scrollTop: myDocument.documentElement.scrollTop || myDocument.body.scrollTop,
                    scrollLeft: myDocument.documentElement.scrollLeft || myDocument.body.scrollLeft,
                    wholeHeight: myDocument.documentElement.scrollHeight,
                    wholeWidth: myDocument.documentElement.scrollWidth,
                    innerHeight: window.innerHeight,
                    innerWidth: window.innerWidth,
                    outerHeight: window.outerHeight,
                    outerWidth: window.outerWidth
                }
            }
</code></pre>
<h3 id='5.2'>5.2 拖拽</h3>
<h4 id="1-行内元素">1) 行内元素</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<h3 id='5.3'>5.3 图片懒加载</h3>
<h4 id="1-行内元素-1">1) 行内元素</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<h3 id='5.4'>5.4 轮播</h3>
<h4 id="1-行内元素-2">1) 行内元素</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<h3 id='5.5'>5.5 滑动</h3>
<h4 id="1-行内元素-3">1) 行内元素</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<h3 id='5.6'>5.6 级联</h3>
<h4 id="1-行内元素-4">1) 行内元素</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<h3 id='5.7'>5.7 图片剪裁</h3>
<h4 id="1-行内元素-5">1) 行内元素</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<h3 id='5.8'>5.8 图片压缩</h3>
<h4 id="1-行内元素-6">1) 行内元素</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<h3 id='5.9'>5.9 Tab</h3>
<h4 id="1-行内元素-7">1) 行内元素</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<hr>
<h2 id='6'>六、CSS效果篇</h2>
<h3 id='6.1'>6.1 水平居中</h3>
<h4 id="1-行内元素-8">1) 行内元素</h4>
<blockquote>
<ul>
<li>父元素上text-align: center;</li>
</ul>
</blockquote>
<pre><code>            // main.html
            &lt;div class=&quot;contain&quot;&gt;
                &lt;span class=&quot;centerText&quot;&gt;我是居中的行内元素&lt;/span&gt;
            &lt;/div&gt;

            // main.css
            @charset &quot;UTF-8&quot;;
            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-07-31
             * @version $0.0.1$
             */
             
            .contain {
                text-align: center;
                background: #000;
            }

             .centerText {
                background: #fff;
            }
</code></pre>
<h4 id="2-块级元素">2) 块级元素</h4>
<blockquote>
<ul>
<li>定宽居中</li>
</ul>
<blockquote>
<ul>
<li>自身元素上margin: auto; 一定要写width;</li>
</ul>
</blockquote>
</blockquote>
<pre><code>            // main.html
            &lt;div class=&quot;contain&quot;&gt;
                &lt;div class=&quot;centerBlock&quot;&gt;我是居中的块级元素&lt;/div&gt;
            &lt;/div&gt;

            // main.css
            @charset &quot;UTF-8&quot;;
            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-07-31
             * @version $0.0.1$
             */
             
            .contain {
                background: #000;
            }

            .centerBlock {
                width: 100px;
                margin: auto;
                background: #fff;
            } 
</code></pre>
<blockquote>
<ul>
<li>inline-block不定宽居中</li>
</ul>
<blockquote>
<ul>
<li>把块状元素的显示值设置为inline-block</li>
<li>然后使用行内元素的text-align: center;</li>
</ul>
</blockquote>
</blockquote>
<pre><code>            // main.html
            &lt;div class=&quot;contain&quot;&gt;
                &lt;div class=&quot;centerBlock&quot;&gt;我是居中的块级元素&lt;/div&gt;
            &lt;/div&gt;

            // main.css
            @charset &quot;UTF-8&quot;;
            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-07-31
             * @version $0.0.1$
             */
             
            .contain {
                text-align: center;
                background: #000;
            }

            .centerBlock {
                display: inline-block;
                background: #fff;
            }
</code></pre>
<blockquote>
<ul>
<li>绝对定位不定宽居中</li>
</ul>
<blockquote>
<ul>
<li>注意IE8及以下不支持transform，其他的也需要加后缀</li>
</ul>
</blockquote>
</blockquote>
<pre><code>            // main.html
            &lt;div class=&quot;contain&quot;&gt;
                &lt;div class=&quot;centerBlock&quot;&gt;我是居中的块级元素&lt;/div&gt;
            &lt;/div&gt;

            // main.css
            @charset &quot;UTF-8&quot;;
            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-07-31
             * @version $0.0.1$
             */
             
            .contain {
                position: relative;
                background: #000;
            }

            .centerBlock {
                display: inline-block;
                position: absolute;
                left: 50%;
                transform: translateX(-50%);
                background: #fff;
            }
</code></pre>
<blockquote>
<ul>
<li>table-cell不定宽居中</li>
</ul>
<blockquote>
<ul>
<li>注意table-cell的特性有点像inline-block，需要设置width，而且不接受百分比，只接受数值，table-cell</li>
<li>IE6 IE7无效</li>
</ul>
</blockquote>
</blockquote>
<pre><code>            // main.html
            &lt;div class=&quot;contain&quot;&gt;
                &lt;div class=&quot;centerBlock&quot;&gt;我是居中的块级元素&lt;/div&gt;
            &lt;/div&gt;

            // main.css
            @charset &quot;UTF-8&quot;;
            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-07-31
             * @version $0.0.1$
             */
             
            .contain {
                display: table-cell;
                width: 400px;
                text-align: center;
                background: #000;
            }

            .centerBlock {
                display: inline-block;
                background: #fff;
            } 
</code></pre>
<h3 id='6.2'>6.2 垂直居中</h3>
<h4 id="1-行内元素-9">1) 行内元素</h4>
<blockquote>
<ul>
<li>父元素需要设置行高</li>
<li>自身元素上设置vertical-align</li>
</ul>
</blockquote>
<pre><code>            // main.html
            &lt;div class=&quot;contain&quot;&gt;
                &lt;span class=&quot;centerText&quot;&gt;我是居中的行内元素&lt;/span&gt;
            &lt;/div&gt;

            // main.css
            @charset &quot;UTF-8&quot;;
            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-07-31
             * @version $0.0.1$
             */
             
            .contain {
                line-height: 400px;
                vertical-align: middle;
                background: #000;
            }

             .centerText {
                background: #fff;
            }
</code></pre>
<h4 id="2-块级元素-1">2) 块级元素</h4>
<blockquote>
<ul>
<li>line-height不定高居中</li>
</ul>
<blockquote>
<ul>
<li>父元素需要设置行高，高度将被行高顶起，相当于设了高度</li>
<li>子元素设置vertical-align: middle，这是因为子元素被设为inline-block后，其基线将于内部文字的中线重合</li>
<li>由于父元素的行高等于自身高度，而子元素的基线在内部文字的中线上，所以就变成竖直居中了</li>
<li>会存在幽灵空白节点的问题，详细看<a href="#6.5">6.5 消除幽灵空格</a></li>
</ul>
</blockquote>
</blockquote>
<pre><code>            // main.html
            &lt;div class=&quot;contain&quot;&gt;
                &lt;div class=&quot;centerBlock&quot;&gt;我是居中的块级元素&lt;/div&gt;
            &lt;/div&gt;

            // main.css
            @charset &quot;UTF-8&quot;;
            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-07-31
             * @version $0.0.1$
             */
             
            .contain {
                line-height: 100px;
                background: #000;
            }

            .centerBlock {
                display: inline-block;
                line-height: 1;
                vertical-align: middle; 
                background: #fff;
            }
</code></pre>
<blockquote>
<ul>
<li>绝对定位不定高居中</li>
</ul>
<blockquote>
<ul>
<li>注意IE8及以下不支持transform，其他的也需要加后缀</li>
<li>父元素需要设置高度</li>
</ul>
</blockquote>
</blockquote>
<pre><code>            // main.html
            &lt;div class=&quot;contain&quot;&gt;
                &lt;div class=&quot;centerBlock&quot;&gt;我是居中的块级元素&lt;/div&gt;
            &lt;/div&gt;

            // main.css
            @charset &quot;UTF-8&quot;;
            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-07-31
             * @version $0.0.1$
             */
             
            .contain {
                position: relative;
                height: 100px;
                background: #000;
            }

            .centerBlock {
                display: inline-block;
                position: absolute;
                top: 50%;
                transform: translateY(-50%);
                background: #fff;
            }
</code></pre>
<blockquote>
<ul>
<li>table-cell不定高居中</li>
</ul>
<blockquote>
<ul>
<li>注意table-cell的特性有点像inline-block</li>
<li>父元素需要设置计算值为table-cell，vertical-align: middle，高度不接受百分比，只接受数值，margin设置无效，响应padding设置</li>
<li>不同于水平居中，子元素不必一定是inline-block，高度会自动适应</li>
<li>IE6 IE7无效</li>
</ul>
</blockquote>
</blockquote>
<pre><code>            // main.html
            &lt;div class=&quot;contain&quot;&gt;
                &lt;div class=&quot;centerBlock&quot;&gt;我是居中的块级元素&lt;/div&gt;
            &lt;/div&gt;

            // main.css
            @charset &quot;UTF-8&quot;;
            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-07-31
             * @version $0.0.1$
             */
             
            .contain {
                display: table-cell;
                height: 400px;
                vertical-align: middle;
                background: #000;
            }

            .centerBlock {
                background: #fff;
            } 
</code></pre>
<h3 id='6.3'>6.3 水平垂直居中</h3>
<h4 id="1-绝对定位auto方案">1) 绝对定位auto方案</h4>
<blockquote>
<ul>
<li>需要已知长度和高度</li>
</ul>
</blockquote>
<pre><code>            // main.html
            &lt;div class=&quot;contain&quot;&gt;
                &lt;div class=&quot;centerBlock&quot;&gt;我是居中的块级元素&lt;/div&gt;
            &lt;/div&gt;

            // main.css
            @charset &quot;UTF-8&quot;;
            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-07-31
             * @version $0.0.1$
             */
             
            .contain {
                position: relative;
                width: 100px;
                height: 100px;
                background: #000;
            }

            .centerBlock {
                display: inline-block;
                position: absolute;
                left: 0;
                right: 0;
                top: 0;
                bottom: 0;
                width: 40px;
                height: 40px;
                margin: auto;
                background: #fff;
            }
</code></pre>
<h4 id="2-绝对定位translate方案">2) 绝对定位translate方案</h4>
<blockquote>
<ul>
<li>不需要已知长度和高度</li>
</ul>
</blockquote>
<pre><code>            // main.html
            &lt;div class=&quot;contain&quot;&gt;
                &lt;div class=&quot;centerBlock&quot;&gt;我是居中的块级元素&lt;/div&gt;
            &lt;/div&gt;

            // main.css
            @charset &quot;UTF-8&quot;;
            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-07-31
             * @version $0.0.1$
             */
             
            .contain {
                position: relative;
                width: 100px;
                height: 100px;
                background: #000;
            }

            .centerBlock {
                display: inline-block;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #fff;
            }
</code></pre>
<h4 id="3-inline-block方案">3) inline-block方案</h4>
<blockquote>
<ul>
<li>vertical-align and text-align</li>
<li>如果子元素内部有多行文字，且没有设vertical-align: middle;那么竖直方向上第一行会往上跳，居中对齐的是最后一行中间。</li>
<li>会存在幽灵空白节点的问题，详细看<a href="#6.5">6.5 消除幽灵空格</a></li>
</ul>
</blockquote>
<pre><code>            // main.html
            &lt;div class=&quot;contain&quot;&gt;
                &lt;div class=&quot;centerBlock&quot;&gt;我是居中的块级元素&lt;/div&gt;
            &lt;/div&gt;

            // main.css
            .contain {
                width: 100px;
                line-height: 100px;
                text-align: center;
                background: #000;
            }

            .centerBlock {
                display: inline-block;
                line-height: 1;
                vertical-align: middle;
                background: #fff;
            }
</code></pre>
<h4 id="4-table-cell方案">4) table-cell方案</h4>
<blockquote>
<ul>
<li>不需要理会行高的问题，只用text-align和vertical-align就能保证</li>
<li>自身元素计算值设为inline-block</li>
</ul>
</blockquote>
<pre><code>            // main.html
            &lt;div class=&quot;contain&quot;&gt;
                &lt;div class=&quot;centerBlock&quot;&gt;我是居中的块级元素&lt;/div&gt;
            &lt;/div&gt;

            // main.css
            @charset &quot;UTF-8&quot;;
            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-07-31
             * @version $0.0.1$
             */
             
            .contain {
                display: table-cell;
                width: 100px;
                height: 100px;
                text-align: center;
                vertical-align: middle;
                background: #000;
            }

            .centerBlock {
                display: inline-block;
                background: #fff;
            }
</code></pre>
<h3 id='6.4'>6.4 清除浮动</h3>
<h4 id="1-原因">1) 原因</h4>
<blockquote>
<ul>
<li>对于块级元素，当其高度没有被指定的时候，其高度由内部的存在于文档流中的元素的高度所决定。但是，问题来了，如果内部的某个元素由于浮动或者绝对定位等原因脱离了文档流，但么块级元素的高度可能会发生变化(变小)，严重的可能会引起高度坍塌。</li>
<li><a href="https://segmentfault.com/a/1190000007030144">浮动元素会脱离文档流但不会脱离文本流，因而会造成文本环绕效果，而这也是浮动的本意。</a></li>
<li><a href="https://segmentfault.com/a/1190000007030144">浮动元素的外边距不会合并</a></li>
<li><a href="https://segmentfault.com/a/1190000007030144">浮动非替换元素时必须设定宽度</a></li>
<li><a href="https://segmentfault.com/a/1190000007030144">浮动元素会脱离文档流但不会脱离文本流，因而会造成文本环绕效果，而这也是浮动的本意。</a></li>
<li><a href="https://segmentfault.com/a/1190000007030144">不管是块级元素还是内联元素，一旦浮动就会变成行内块元素（即display: inline-block;）</a></li>
<li><a href="https://segmentfault.com/a/1190000007030144">如果浮动元素应用了负外边距而导致其与相邻元素重叠，分两种情况：</a></li>
</ul>
<blockquote>
<ul>
<li><a href="https://segmentfault.com/a/1190000007030144">行内框与一个浮动元素重叠时，其边框、背景和内容都在该浮动元素之上显示</a></li>
<li><a href="https://segmentfault.com/a/1190000007030144">块框与一个浮动元素重叠时，其边框和背景都在该浮动元素之下显示，而内容在浮动元素之上显示</a></li>
</ul>
</blockquote>
</blockquote>
<h4 id="2-解决办法">2) 解决办法</h4>
<blockquote>
<ul>
<li>BFC block-formatting context 块级格式化上下文</li>
<li>BFC有一个特性：内部元素无论怎么'折腾'，都不会干扰外部的元素。这意味着不会发生margin重叠，也不会发生高度坍塌。</li>
</ul>
<blockquote>
<ul>
<li>html根元素</li>
<li>float的值不为none；</li>
<li>position的值不为relative和static</li>
<li>overflow为auto，scroll，hidden</li>
<li>display的值为table-cell、table-caption和inline-block</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p><img src="https://github.com/hblvsjtu/FET/blob/master/picture/%E5%9B%BE6-1%20%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8.png?raw=true" alt="图6-1 清除浮动"></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<pre><code>            // main.html
            &lt;div class=&quot;contain&quot;&gt;
                &lt;div class=&quot;floatBlock&quot;&gt;我是正常元素&lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;contain&quot;&gt;
                &lt;div class=&quot;floatBlock&quot;&gt;我是浮动元素造成了坍塌&lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;contain&quot;&gt;
                &lt;div class=&quot;floatBlock&quot;&gt;我是浮动元素经过了overflow：hidden修复&lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;contain&quot;&gt;
                &lt;div class=&quot;floatBlock&quot;&gt;我是浮动元素经过了父元素inline-block修复&lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;contain&quot;&gt;
                &lt;div class=&quot;floatBlock&quot;&gt;我是浮动元素经过了父元素clear:both修复&lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;contain&quot;&gt;
                &lt;div class=&quot;floatBlock&quot;&gt;我是浮动元素经过了父元素absolute修复&lt;/div&gt;
            &lt;/div&gt;

            // main.css
            @charset &quot;UTF-8&quot;;
            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-07-31
             * @version $0.0.1$
             */
             
            .contain {
                width: 400px;
                background: #000;
            }

            .floatBlock {
                display: inline-block;
                width: 200px;
                margin: 10px;
                height: 50px;
                background: #fff;
            }

            .contain:nth-child(2) .floatBlock,
            .contain:nth-child(3) .floatBlock,
            .contain:nth-child(4) .floatBlock,
            .contain:nth-child(5) .floatBlock,
            .contain:nth-child(6) .floatBlock {
                float: left;
            }

            .contain:nth-child(3){
                overflow: hidden;
            }

            .contain:nth-child(4) {
                display: inline-block;
            }

            .contain:nth-child(5) {
                zoom: 1;
            }
            .contain:nth-child(5)::after {
                content: '';
                display: block;
                height: 0;
                visibility: hidden;
                clear: both;
            }

            .contain:nth-child(6) {
                position: absolute;
            }
</code></pre>
<h3 id='6.5'>6.5 幽灵空白节点</h3>
<h4 id="1-w3c规范">1) W3C规范</h4>
<blockquote>
<ul>
<li>line boxes are created as needed to hold inline-level content within an inline formatting context. Line boxes that contain no text, no preserved white space, no inline elements with non-zero margins, padding, or borders, and no other in-flow content (such as images, inline blocks or inline tables), and do not end with a preserved newline must be treated as zero-height line boxes for the purposes of determining the positions of any elements inside of them, and must be treated as not existing for any other purpose.</li>
<li>如果一个line box里没有文字、保留的空格、非0的margin或padding或border的inline元素、或其他in-flow内容（比如图片、inline-block或inline-table元素），且不以保留的换行符结束的话，就会被视作高度为0的line box。但是一旦出现以上任意一种情况，就会出现幽灵空白节点。说白点，行框里只要有in-flow（图片、inline-block或inline-table元素），就会出现幽灵空白节点</li>
<li>在一个行框内，对于一个inline-block，如果内部没有文字，或者overflow不是visible，那么他的基线将在于margin底部，如果里面有文字，将于最后一行文字的基线对齐</li>
</ul>
</blockquote>
<h4 id="2-如何消除呢">2) 如何消除呢？</h4>
<blockquote>
<ul>
<li>设置父元素font-size为0，然后再把子元素的font-size恢复</li>
</ul>
</blockquote>
<h3 id='6.6'>6.6 三列布局</h3>
<h4 id="1-双飞翼布局">1) 双飞翼布局</h4>
<blockquote>
<ul>
<li>两侧宽度固定，中间宽度自适应</li>
<li>中间的dom优先渲染</li>
<li>允许三列中任意一列成为最高列</li>
<li>额外使用了一个div标签，该div是用来取得内层center的宽度了，避免计算calc(100%-350px)</li>
<li>margin-left: -100%; //使得左栏放到上一行的最左边</li>
<li>margin-left: -右栏宽度; //使得右栏放到上一行的最右边</li>
<li>为了避免中间栏被挤掉，需要设置body的最小宽度</li>
</ul>
</blockquote>
<pre><code>            // main.html
            &lt;div class=&quot;container column&quot;&gt;
                &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class=&quot;left column&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;right column&quot;&gt;&lt;/div&gt;

            // main.css
            @charset &quot;UTF-8&quot;;
            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-07-31
             * @version $0.0.1$
             */
             
            body {
                min-width: 500px;
            }

            .column {
              float: left;
              height: 100px;
            }

            .container {
              width: 100%;
            }

            .container .center {
              height: 100%;
              margin-left: 200px;
              margin-right: 150px;
              background: red;
            }

            .left {
              width: 200px;
              margin-left: -100%;
              background: yellow; 
            }

            .right {
              width: 150px;
              margin-left: -150px;
              background: green; 
            }
</code></pre>
<blockquote>
<ul>
<li>不用div包裹内部center的版本 目前需要计算计算calc(100%-350px)，calc()支持到IE9。</li>
</ul>
</blockquote>
<pre><code>            // main.html
            &lt;div class=&quot;center column&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;left column&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;right column&quot;&gt;&lt;/div&gt;

            // main.css
            @charset &quot;UTF-8&quot;;
            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-07-31
             * @version $0.0.1$
             */
             
            body {
                min-width: 350px; // 200px + 150px
            }

            .column {
                float: left;
                height: 100px;
            }

            .center {
                width: calc(100% - 200px - 150px);
                margin-left: 200px;
                margin-right: 150px;
                background: red;
            }

            .left {
                width: 200px;
                margin-left: -100%;
                background: yellow; 
            }

            .right {
                width: 150px;
                margin-left: -150px;
                background: green; 
            }
</code></pre>
<h4 id="2-圣杯布局">2) 圣杯布局</h4>
<blockquote>
<ul>
<li>多一个div作为container</li>
<li>container的左右padding为左右栏留出空位</li>
<li>左右栏使用relative作平移补偿</li>
</ul>
</blockquote>
<pre><code>            // main.html
            &lt;div class=&quot;container&quot;&gt;
                &lt;div class=&quot;center column&quot;&gt;&lt;/div&gt;
                &lt;div class=&quot;left column&quot;&gt;&lt;/div&gt;
                &lt;div class=&quot;right column&quot;&gt;&lt;/div&gt;
            &lt;/div&gt;

            // main.css
            @charset &quot;UTF-8&quot;;
            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-07-31
             * @version $0.0.1$
             */
             
            body {
                min-width: 550px; // 200px+150px+200px
            }

            .container {
                padding-left: 200px;
                padding-right: 150px;
                height: 100px;
            }

            .column {
                float: left;
                height: 100%;
            }

            .center {
                width: 100%;
                background: red;
            }

            .left {
                position: relative;
                left: -200px;
                width: 200px;
                margin-left: -100%;
                background: yellow; 
            }

            .right {
                position: relative;
                right: -150px;
                width: 150px;
                margin-left: -150px;
                background: green; 
            }
</code></pre>
<h4 id="3-简单float布局">3) 简单float布局</h4>
<blockquote>
<ul>
<li>左右分别来一个float，中间用margin撑开</li>
<li>center只能放在下面，否则会挤掉left和right</li>
<li>缺点：center最后才渲染，而且center的文字流会收到left和right的影响</li>
</ul>
</blockquote>
<pre><code>            // main.html
            &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;

            // main.css
            @charset &quot;UTF-8&quot;;
            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-07-31
             * @version $0.0.1$
             */

            body {
                min-width: 350px;
            }

            .center {
                height: 100px;
                margin-left: 200px;
                margin-right: 150px;
                background: red;
            }

            .left {
                float: left;
                width: 200px;
                height: 100px;
                background: yellow; 
            }

            .right {
                float: right;
                width: 150px;
                height: 100px;
                background: green; 
            }
</code></pre>
<h4 id="4-绝对float布局">4) 绝对float布局</h4>
<blockquote>
<p>多一个div作为包裹
简单易用，兼容性好
中间最先出</p>
</blockquote>
<pre><code>            // main.html
            &lt;div class=&quot;container&quot;&gt;
                &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;
                &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
                &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
            &lt;/div&gt;

            // main.css
            @charset &quot;UTF-8&quot;;
            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-07-31
             * @version $0.0.1$
             */

            body {
                min-width: 350px;
            }

            .container {
                position: relative;
                height: 100px;
                overflow: hidden;
            }

            .center {
                position: absolute;
                left: 200px;
                right: 150px;
                top: 0;
                bottom: 0;
                background: red;
            }

            .left {
                float: left;
                width: 200px;
                height: 100px;
                background: yellow; 
            }

            .right {
                float: right;
                width: 150px;
                height: 100px;
                background: green; 
            }
</code></pre>
<h4 id="5-绝对布局">5) 绝对布局</h4>
<blockquote>
<p>多一个div作为包裹
简单易用，兼容性好
中间最先出</p>
</blockquote>
<pre><code>            // main.html
            &lt;div class=&quot;container&quot;&gt;
                &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;
                &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
                &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
            &lt;/div&gt;

            // main.css
            @charset &quot;UTF-8&quot;;
            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-07-31
             * @version $0.0.1$
             */

            body {
                min-width: 350px;
            }

            .container {
                position: relative;
                height: 100px;
            }

            .center {
                position: absolute;
                left: 200px;
                right: 150px;
                top: 0;
                bottom: 0;
                background: red;
            }

            .left {
                position: absolute;
                left: 0;
                top: 0;
                bottom: 0;
                float: left;
                width: 200px;
                background: yellow; 
            }

            .right {
                position: absolute;
                right: 0;
                top: 0;
                bottom: 0;
                width: 150px;
                background: green; 
            }
</code></pre>
<h3 id='6.7'>6.7 弹性布局</h3>
<h4 id="1-容器">1) 容器</h4>
<blockquote>
<ul>
<li>display: flex;    // 将块级元素设置为容器</li>
<li>display: inline-flex    // 将行内元素设置为容器</li>
<li>当元素设置成弹性容器后，它的所有子元素变成弹性项目此时项目的float/clear/vertical-align属性会失效</li>
</ul>
</blockquote>
<h4 id="2-主轴方向flex-direction">2) 主轴方向：flex-direction:</h4>
<blockquote>
<ul>
<li>row，默认值，主轴是x轴，主轴起点是左端</li>
<li>row-reverse,  主轴是x轴，主轴起点是右端</li>
<li>column，主轴是y轴，主轴起点在顶部</li>
<li>column-reverse,主轴是y轴，主轴起点在底部</li>
</ul>
</blockquote>
<h4 id="3-换行显示flex-wrap">3) 换行显示：flex-wrap</h4>
<blockquote>
<ul>
<li>nowrap 默认值，空间不够时，也不换行，项目自动缩小</li>
<li>wrap 空间不够就换行</li>
<li>wrap-reverse 换行，并反转</li>
</ul>
</blockquote>
<h4 id="4-flex-flow">4) flex-flow</h4>
<blockquote>
<ul>
<li>flex-direction + flex-wrap</li>
</ul>
</blockquote>
<h4 id="5-定义项目在主轴上的对齐方式justify-content">5) 定义项目在主轴上的对齐方式：justify-content</h4>
<blockquote>
<ul>
<li>flex-start,默认值，以主轴起点对齐</li>
<li>flex-end，以主轴终点对齐</li>
<li>center  在主轴上居中对齐</li>
<li>space-between 两端对齐，两端无空白</li>
<li>space-around 每个间距大小相同，两边会留白</li>
</ul>
</blockquote>
<h4 id="6-定义项目在交叉轴上的对齐方式align-items">6) 定义项目在交叉轴上的对齐方式：align-items</h4>
<blockquote>
<ul>
<li>flex-start 交叉轴起点对齐</li>
<li>flex-end 交叉轴终点对齐</li>
<li>center 交叉轴居中对齐</li>
<li>baseline 交叉轴基线对齐，就是交叉轴起点</li>
<li>stretch 前提，项目不写高。占满交叉轴上所有的空间</li>
</ul>
</blockquote>
<h4 id="7-项目中的属性">7) 项目中的属性</h4>
<blockquote>
<ul>
<li>order 定义项目排列顺序，值越小，越靠近起点，默认值为0</li>
<li>flex-grow 定义项目的放大比例 取值：无单位整数，默认值0，不放大</li>
<li>flex-shrink 定义项目缩小的比例，容器空间不足时，项目该如何缩小。默认值为1。 取值为0，不缩小。取值越大，缩小越快。</li>
<li>flex-basis 主轴存在剩余空间时，分配给此项目多少空间，默认auto即本身宽度</li>
<li>flex: 默认值是 0 1 auto</li>
</ul>
</blockquote>
<h4 id="7-align-self">7) align-self</h4>
<blockquote>
<ul>
<li>子项目自身的交叉轴对齐方式，会覆盖容器的align-item属性</li>
</ul>
</blockquote>
<h4 id="8-flex-grow和flex-shrink相关计算公式">8) flex-grow和flex-shrink相关计算公式</h4>
<blockquote>
<ul>
<li>子元素空间 &lt; 父容器</li>
</ul>
</blockquote>
<pre><code>            父容器剩余空间 = 父容器宽度 - 子元素宽度之和
            增长单位 = 父容器剩余空间 / 各子元素flex-grow之和
            子元素实际宽度 = (flex-basis) + 增长单位 * (flex-grow)
</code></pre>
<blockquote>
<ul>
<li>子元素空间 &gt; 父容器</li>
</ul>
</blockquote>
<pre><code>            子元素溢出的宽度 = 子元素的宽度之和 - 子元素宽度之和
            收缩单位 = 子元素溢出的宽度 / 各子元素flex_shrink之和
            计算的子元素的宽度 = (flex-basis) - 收缩单位*(flex-shrink)
</code></pre>
<h4 id="9-手写一个圣杯布局">9) 手写一个圣杯布局</h4>
<blockquote>
<ul>
<li>包括header,nav,main,aside,footer</li>
</ul>
</blockquote>
<pre><code>            // mian.html
            &lt;header&gt;header&lt;/header&gt;
            &lt;div class=&quot;container&quot;&gt;
                &lt;main&gt;main&lt;/main&gt;
                &lt;nav&gt;nav&lt;/nav&gt;
                &lt;aside&gt;aside&lt;/aside&gt;
            &lt;/div&gt;
            &lt;footer&gt;footer&lt;/footer&gt;


            // mian.css
            @charset &quot;UTF-8&quot;;
            /**
             * 
             * @authors ${冰红茶} (${hblvsjtu@163.com})
             * @date    2019-07-31
             * @version $0.0.1$
             */

            body {
                display: flex;
                flex-flow: column wrap; 
                min-width: 350px;
                min-height: 500px;
                height: 100%;
            }

            header,
            footer {
                display: flex;
                justify-content: center;
                align-items: center;
                flex: 0 0 100px;
                background: gray;
            }

            header {
                order: 1;
            }

            footer {
                order: 3;
            }

            .container {
                display: flex;
                flex-flow: row nowrap;
                order: 2;
                flex: 1 1 auto;
            }

            .container main {
                order: 2;
                flex: 1 1 auto;
                background: red;
            }

            .container nav {
                order: 1;
                flex: 0 0 200px;
                background: yellow;
            }

            .container aside {
                order: 3;
                flex: 0 0 150px;
                background: green;
            }

            .container main,
            .container nav,
            .container aside {
                display: flex;
                justify-content: center;
                align-items: center;
            }
</code></pre>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p><img src="https://github.com/hblvsjtu/FET/blob/master/picture/%E5%9B%BE6-2%20flex%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80.png?raw=true" alt="图6-2 flex圣杯布局"></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h3 id='6.8'>6.8 响应式布局</h3>
<h4 id="1-null-1">1) null</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<h3 id='6.9'>6.9 变形动画</h3>
<h4 id="1-二维动画">1) 二维动画</h4>
<blockquote>
<ul>
<li>引自<a href="https://segmentfault.com/a/1190000015236871">落霞与孤鹜齐飞</a></li>
</ul>
</blockquote>
<pre><code>            transform: translate(x, y); 沿着 X 和 Y 轴移动元素。
            transform: translate(100px, 100px);

            transform: rotate(angle); 旋转元素。
            transform: rotate(45deg);

            transform: scale(x, y); 倍数改变元素的宽度和高度。
            transform: scale(2, 3);

            transform: skew(x, y); 沿着 X 和 Y 轴倾斜。
            transform: skew(45deg, -45deg);

            transform-origin: x y; 旋转的基点位置（默认center center）。
            transform-origin: right bottom;

            transform: translateX(45px) rotate(45deg); 合并简写
</code></pre>
<h4 id="2-三维动画">2) 三维动画</h4>
<blockquote>
<ul>
<li>引自<a href="https://segmentfault.com/a/1190000015236871">落霞与孤鹜齐飞</a></li>
<li>preserve-3d：保证所有子元素都处于同一个三维空间</li>
<li>perspective定义摄像机（也就是作为观众的我们）到屏幕的距离</li>
<li>perspective-origin定义摄像机观察到的画面中的灭点（vanishing point）的位置</li>
</ul>
</blockquote>
<pre><code>            transform-style: preserve-3d;
            perspective: 24px;  设置元素被查看位置的视图  
            perspective-oragin: center center; 改变视点的位置

            transform: translate3d();
            transform: translateX();
            transform: translateY();
            transform: translateZ();

            transform: rotate3d();
            transform: rotateX();
            transform: rotateY();
            transform: rotateZ();

            transform: scale3d();
            transform: scaleX();
            transform: scaleY();
            transform: scaleZ();
</code></pre>
<h3 id='6.10'>6.10 补间动画</h3>
<h4 id="1-null-2">1) null</h4>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<hr>
<h2 id='9'>九、浏览器篇</h2>
<h3 id='9.3'>9.3 defer和async的区别</h3>
<h4 id="1-相同点-1">1) 相同点</h4>
<blockquote>
<ul>
<li>都用在script的异步脚本加载中，</li>
</ul>
</blockquote>
<h4 id="2-不同点-1">2) 不同点</h4>
<blockquote>
<ul>
<li>脚本的执行时间和执行顺序</li>
<li>async的脚本是看那个脚本最先下载完成先执行，跟写在HTML上的顺序是不同的</li>
<li>defer实在DOM解析完成后，DOMContentLoaded 事件触发之前完成的，一般是按照写在HTML上的顺序执行，但是实际体验下来这个顺序不能保证</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p><img src="https://github.com/hblvsjtu/FET/blob/master/picture/%E5%9B%BE9-1%20async%E5%92%8Cdefer%E7%9A%84%E5%8C%BA%E5%88%AB.png?raw=true" alt="图9-1 async和defer的区别"></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h3 id='9.5'>9.5 浏览器性能和计时器</h3>
<h4 id="1-高消耗的样式">1) 高消耗的样式</h4>
<blockquote>
<ul>
<li>box-shadows</li>
<li>border-radius</li>
<li>transparency</li>
<li>transforms</li>
<li>CSS filters（性能杀手）</li>
</ul>
</blockquote>
<h4 id="2-减少重排reflow的经验">2) 减少重排Reflow的经验</h4>
<blockquote>
<ul>
<li>不要逐条修改CSS样式，最好预先写成class，再使用dom.classList.add()</li>
<li>离线修改DOM: 先把 DOM 给 display:none, 再把它还原；</li>
<li>为动画的元素使用绝对定位 absolute / fixed</li>
<li>不要使用 table 布局</li>
</ul>
</blockquote>
<h4 id="3-优化动画性能">3) 优化动画性能</h4>
<blockquote>
<ul>
<li>GPU （Graphics Processing Unit） 是图像处理器，再处理图像上更加有效率</li>
<li>GPU加速可以不仅应用于3D，而且也可以应用于2D，常用的场合：Canvas2D，布局合成（Layout Compositing）, CSS3转换（transitions），CSS3 3D变换（transforms），WebGL和视频(video)。</li>
<li>所以如果需要提升transforms的性能，可以强制为它开启3D，如transform: translate3d(10px, 10px, 0);</li>
<li>或者使用&quot;transform:translateZ(0);</li>
</ul>
</blockquote>
<pre><code>            .cube { 
                -webkit-transform: translateZ(0); 
                -moz-transform: translateZ(0); 
                -ms-transform: translateZ(0); 
                -o-transform: translateZ(0); 
                transform: translateZ(0);
            }
</code></pre>
<blockquote>
<ul>
<li>在 Chrome 和 Safari中， 以下声明可以解决转换或动画可能会看到闪烁的效果</li>
</ul>
</blockquote>
<pre><code>            .cube { 
                -webkit-backface-visibility: hidden;
                -moz-backface-visibility: hidden;
                -ms-backface-visibility: hidden;
                backface-visibility: hidden;
                -webkit-perspective: 1000;
                -moz-perspective: 1000;
                -ms-perspective: 1000;
                perspective: 1000;
            }   
</code></pre>
<blockquote>
<ul>
<li>那问题来了，为什么开启3D来打开GPU加速可以优化动画性能呢？因为浏览器DOM渲染需要经过重排和重绘两个过程，其中重排的消耗最大。那问题就来到如果减少重排和重绘，甚至避免重排和重绘，借此提高动画的性能。动画是有帧组成的连续画面，开启GPU加速，即是GPU计算'层'，或者叫「纹理」，实际上是是DOM快照，通过已知变换矩阵来修改'层'，实质上是位图，来避免DOM的重排和重绘。</li>
<li>那问题又来了：什么情况下会触发层的创建呢？引自<a href="https://github.com/ccforward/cc/issues/42">chokcoco的回答</a></li>
</ul>
<blockquote>
<ul>
<li>3D 或透视变换(perspective、transform) CSS 属性</li>
<li>使用加速视频解码的 元素</li>
<li>拥有 3D (WebGL) 上下文或加速的 2D 上下文的 元素</li>
<li>混合插件(如 Flash)</li>
<li>对自己的 opacity 做 CSS 动画或使用一个动画变换的元素</li>
<li>拥有加速 CSS 过滤器的元素， 如：</li>
</ul>
</blockquote>
</blockquote>
<pre><code>            filter: brightness(50%); // 明度滤镜
            filter: saturate(1000%); // 饱和度滤镜
            filter: blur(5px); // 模糊滤镜
            filter: hue-rotate(45deg); // 色相反转滤镜
            filter: invert(100%); // 颜色反转滤镜
            filter: contrast(25%); // 对比度滤镜
            filter: drop-shadow(5px 5px 5px red); //阴影滤镜 第一个值是X方向上的位移，第二个值是Y轴方向上的位移，第三个值是模糊的大小，第四个值是模糊的颜色。
</code></pre>
<blockquote>
<blockquote>
<ul>
<li>元素有一个包含复合层的后代节点，换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)</li>
<li>元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染</li>
</ul>
</blockquote>
</blockquote>
<hr>
<h2 id='10'>十、V8引擎篇</h2>
<h3 id='10.0'>10.0 事件循环</h3>
<h4 id="1-主线程">1) 主线程</h4>
<blockquote>
<ul>
<li>JS异步单线程里面的单线程指的是就是主线程，或者平常所说的『main』函数</li>
</ul>
</blockquote>
<h4 id="2-任务队列macrotasks">2) 任务队列(Macrotasks)</h4>
<blockquote>
<ul>
<li>当主线程在运作的时候，异步方法在指定的事件发生后，就会保存到一个队列中；当主线程在空闲时的时候，系统将会遍历该队列里面的方法并一一顺序执行。此队列就是'任务队列'。</li>
<li>比如dom事件、setTimeout、setInterval、ajax事件</li>
</ul>
</blockquote>
<h4 id="3-微任务队列microtasks">3) 微任务队列(Microtasks)</h4>
<blockquote>
<ul>
<li>就是在主线程和任务队列隔着的一层队列，当主线程空闲时，先遍历微任务队列并把里面的任务一一顺序执行，再遍历任务队列并一一顺序执行里面的方法。</li>
<li>如promise、process.nextTicks、MutationObserver</li>
</ul>
</blockquote>

    </body>
    </html>